<!DOCTYPE html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta charset="utf-8">
<title>设计模式白话篇 - 老郭记事</title>
<meta name="description" content="">
<meta name="author" content="">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
<link rel="stylesheet" href="assets/css/bulma.min.css">
<link rel="stylesheet" href="assets/css/app.css">
<!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->
<link rel="shortcut icon" href="">
</head>
<body dir="ltr">

<nav class="columns navbar">
  <div class="column logo is-3 is-offset-1">
    <a class="is-brand" href="index.html">
      老郭记事
    </a>
  </div>
</nav>

<div class="columns content">
  <div class="column is-2-desktop is-3-widescreen is-hidden-touch">
  </div>
  <div class="column article-container is-11-tablet is-8-desktop is-6-widescreen">
    <div class="breadcrumb-area"><a href="index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="设计模式.html" class="breadcrumb-item">设计模式白话篇</a></div>
    <h1 class="article-title">设计模式白话篇</h1>
    <div class="article">
      <p>Design Patterns: Elements of Reusable Object-Oriented Software（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为“四人组（Gang of Four）”，而这本书也就被称为“四人组（或 GoF）”书。<br>
在《设计模式》这本书的最大部分是一个目录，该目录列举并描述了 23 种设计模式。</p>
<h1 id="创建型模式">创建型模式 <a class="markdownIt-Anchor" href="#创建型模式">#</a></h1>
<h2 id="工厂模式-factory">工厂模式 FACTORY <a class="markdownIt-Anchor" href="#工厂模式-factory">#</a></h2>
<ol>
<li>FACTORY—追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory</li>
</ol>
<p>工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<pre class="hljs"><code><span class="hljs-comment">//篮球基类</span>
<span class="hljs-keyword">var</span> BasketBall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.intro = <span class="hljs-string">'篮球盛行于美国'</span>;
}
BasketBall.prototype = {
    <span class="hljs-attr">getmember</span> :<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'每个队伍需要5名队员'</span>);
    },
    <span class="hljs-attr">getBallSize</span> :<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'篮球很大'</span>);
    }
}

<span class="hljs-comment">// 足球基类</span>
<span class="hljs-keyword">var</span> Football = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.intro = <span class="hljs-string">'足球在世界范围内很流行'</span>;
}
Football.prototype = {
    <span class="hljs-attr">getmember</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'每个队伍需要 11 名队员'</span>)
    },
    <span class="hljs-attr">getBallSize</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'足球很大'</span>);
    }
}

<span class="hljs-comment">// 网球基类</span>
<span class="hljs-keyword">var</span> Tennis = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.intro = <span class="hljs-string">'每年有很多网球系列赛'</span>;
}
Tennis.prototype = {
    <span class="hljs-attr">getmember</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'每个队伍需要 1 名队员'</span>)
    },
    <span class="hljs-attr">getBallSize</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'网球很小'</span>);
    }
}

<span class="hljs-comment">// 创建一个运动工厂</span>
<span class="hljs-keyword">var</span> SportFactory = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">switch</span>(name){
        <span class="hljs-keyword">case</span> <span class="hljs-string">'NBA'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'CBA'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasketBall();
        <span class="hljs-keyword">case</span> <span class="hljs-string">'world cup'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Football();
        <span class="hljs-keyword">case</span> <span class="hljs-string">'FrenchOpen'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tennis();
    }
}

<span class="hljs-keyword">var</span> a = SportFactory(<span class="hljs-string">'NBA'</span>);
a.getBallSize();
<span class="hljs-keyword">var</span> b = SportFactory(<span class="hljs-string">'CBA'</span>);
b.getBallSize();


<span class="hljs-comment">//模拟一个登录类</span>
<span class="hljs-keyword">var</span> LoginAlert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>)</span>{
    <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>)</span>{
        <span class="hljs-built_in">console</span>.log(text)
    }
}
<span class="hljs-keyword">var</span> LoginConfirm = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>)</span>{
    <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(text)
    }
}
<span class="hljs-keyword">var</span> LoginPrompt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>)</span>{
    <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(text)
    }
}
<span class="hljs-comment">// 方案类似多态</span>
<span class="hljs-keyword">var</span> PopFactory = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">switch</span>(name){
        <span class="hljs-keyword">case</span> <span class="hljs-string">'alert'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoginAlert();
        <span class="hljs-keyword">case</span> <span class="hljs-string">'confirm'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoginConfirm();
        <span class="hljs-keyword">case</span> <span class="hljs-string">'prompt'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoginPrompt();
    }
}

<span class="hljs-keyword">var</span> passwordMsg = <span class="hljs-keyword">new</span> PopFactory(<span class="hljs-string">'alert'</span>);
passwordMsg.say(<span class="hljs-string">'密码错误'</span>);

<span class="hljs-comment">// 将相似的机构整理归纳</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createBook</span>(<span class="hljs-params">name,time,type</span>)</span>{
    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
    o.name = name;
    o.time = time;
    o.type = type;
    o.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
    <span class="hljs-keyword">return</span> o;
}

<span class="hljs-keyword">var</span> book1 = createBook(<span class="hljs-string">'js book'</span>,<span class="hljs-number">2014</span>,<span class="hljs-string">'js'</span>);
<span class="hljs-keyword">var</span> book2 = createBook(<span class="hljs-string">'css book'</span>,<span class="hljs-number">2013</span>,<span class="hljs-string">'css'</span>);

book1.getName();
book2.getName();

<span class="hljs-comment">// 讲注册模块抽象</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPop</span>(<span class="hljs-params">type,text</span>)</span>{
    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
    o.content = text;
    o.show = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">// 显示dom 的方法</span>
        <span class="hljs-built_in">console</span>.log(text);
    }
    <span class="hljs-keyword">if</span>(type == <span class="hljs-string">'alert'</span>){
        <span class="hljs-comment">// 警示框差异部分</span>
    }
    <span class="hljs-keyword">if</span>(type == <span class="hljs-string">'prompt'</span>){
        <span class="hljs-comment">// 显示弹出</span>
    }
    <span class="hljs-keyword">if</span>(type == <span class="hljs-string">'confirm'</span>){
        <span class="hljs-comment">// 确认框</span>
    }
    <span class="hljs-keyword">return</span> o;
}

<span class="hljs-keyword">var</span> userNameAlert = createPop(<span class="hljs-string">'alert'</span>,<span class="hljs-string">'用户名字只能是26个字母'</span>)
userNameAlert.show();
</code></pre>
<h2 id="建造模式-builder">建造模式 BUILDER <a class="markdownIt-Anchor" href="#建造模式-builder">#</a></h2>
<ol start="2">
<li>BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）</li>
</ol>
<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
<pre class="hljs"><code><span class="hljs-comment">//创建一个人类</span>
<span class="hljs-keyword">var</span> Human = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>)</span>{
    <span class="hljs-comment">//技能</span>
    <span class="hljs-keyword">this</span>.skill = param &amp;&amp; param.skill || <span class="hljs-string">'保密'</span>;
    <span class="hljs-comment">//兴趣爱好</span>
    <span class="hljs-keyword">this</span>.hobby = param &amp;&amp; param.hobby || <span class="hljs-string">'保密'</span>;
}
<span class="hljs-comment">// 人类原型方法</span>
Human.prototype = {
    <span class="hljs-attr">getSkill</span> :<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.skill;
    },
    <span class="hljs-attr">getHobby</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.hobby;
    }
}
<span class="hljs-comment">// 实例化姓名类</span>
<span class="hljs-keyword">var</span> Named = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// 构造器</span>
    <span class="hljs-comment">// 构造函数解析函数的姓与名</span>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name,that</span>)</span>{
        that.wholeName = name;
        <span class="hljs-keyword">if</span>(name.indexOf(<span class="hljs-string">' '</span>)&gt;<span class="hljs-number">-1</span>){
            that.firstName = name.slice(<span class="hljs-number">0</span>,name.indexOf(<span class="hljs-string">' '</span>));
            that.secondeName = name.slice(name.indexOf(<span class="hljs-string">' '</span>));
        }
    })(name,that)
}
<span class="hljs-comment">// 实例化职位类</span>
<span class="hljs-keyword">var</span> Work = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">work</span>)</span>{
    <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// 构造器</span>
    <span class="hljs-comment">// 构造函数中通过传入的职位特征来设置相应职位以及描述</span>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">work,that</span>)</span>{
        <span class="hljs-keyword">switch</span>(work){
            <span class="hljs-keyword">case</span> <span class="hljs-string">'code'</span>:
            that.work = <span class="hljs-string">'工程师'</span>;
            that.workDescript = <span class="hljs-string">'每天沉醉于编程'</span>;
            <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'UI'</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">'UE'</span>:
            that.work = <span class="hljs-string">'设计师'</span>,
            that.workDescript = <span class="hljs-string">'设计更似一种艺术'</span>;
            <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'teach'</span>:
            that.work = <span class="hljs-string">'教师'</span>;
            that.workDescript = <span class="hljs-string">'分享也是一种快乐'</span>;
            <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
            that.work = work;
            that.workDescript = <span class="hljs-string">'抱歉我们还不知道怎么描述'</span>;
        }
    })(work,that)
}

<span class="hljs-comment">// 更换期望的工作</span>
Work.prototype.changeWork = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">work</span>)</span>{
    <span class="hljs-keyword">this</span>.work = work;
}
<span class="hljs-comment">// 添加对职位的描述</span>
Work.prototype.changeDescript = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">setence</span>)</span>{
    <span class="hljs-keyword">this</span>.workDescript = setence;
}

<span class="hljs-comment">// 我们最终的目的是要创建一个应聘者，所以需要上面抽象的三个类，这样我们写一个创造者类，在创建者类中我们通过对这三个类组合调用，就可以创建出一个完整的应聘者对象。</span>
<span class="hljs-comment">/*
    应聘者创建者
    参数 name: 姓名（全名）
    参数 work: 期望职位
*/</span>

<span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name,work</span>)</span>{
    <span class="hljs-comment">// 创建应聘者缓存对象</span>
    <span class="hljs-keyword">var</span> _person = <span class="hljs-keyword">new</span> Human();
    <span class="hljs-comment">// 创建应聘者解析姓名解析对象</span>
    _person.name = <span class="hljs-keyword">new</span> Named(name);
    <span class="hljs-comment">// 创建应聘者期望职位</span>
    _person.work = <span class="hljs-keyword">new</span> Work(work);
    <span class="hljs-comment">// 将创建对象返回</span>
    <span class="hljs-keyword">return</span> _person;
}

<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'xiao ming'</span>,<span class="hljs-string">'code'</span>);

<span class="hljs-built_in">console</span>.log(person.skill); <span class="hljs-comment">// 保密</span>
<span class="hljs-built_in">console</span>.log(person.name.firstName);
<span class="hljs-built_in">console</span>.log(person.skill)
</code></pre>
<h2 id="工厂方法模式-factory-method">工厂方法模式 FACTORY METHOD <a class="markdownIt-Anchor" href="#工厂方法模式-factory-method">#</a></h2>
<ol start="3">
<li>FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。</li>
</ol>
<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<pre class="hljs"><code><span class="hljs-comment">// 通过对产品类的抽象，使其创建业务主要负责用于创建多类产品的实例</span>
<span class="hljs-comment">//  广告展现形式，要求根据类别使用不同的背景色</span>
<span class="hljs-keyword">var</span> Java = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
    <span class="hljs-comment">// 将内容保存在 content 里面已备日后使用</span>
    <span class="hljs-keyword">this</span>.content = content;
    <span class="hljs-comment">// 创建对象时，通过闭包直接执行，将内容按需求的样式插入到页面内</span>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
        div.innerHTML = content;
        div.style.color = <span class="hljs-string">'green'</span>;
        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>).appendChild(div);
    })(content);
}

<span class="hljs-keyword">var</span> PHP = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
    <span class="hljs-comment">// 将内容保存在 content 里面已备日后使用</span>
    <span class="hljs-keyword">this</span>.content = content;
    <span class="hljs-comment">// 创建对象时，通过闭包直接执行，将内容按需求的样式插入到页面内</span>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
        div.innerHTML = content;
        div.style.color = <span class="hljs-string">'red'</span>;
        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>).appendChild(div);
    })(content);
}

<span class="hljs-keyword">new</span> Java(<span class="hljs-string">'这里展示JAVA文案'</span>);
<span class="hljs-keyword">new</span> PHP(<span class="hljs-string">'这里展示PHP文案'</span>);

<span class="hljs-comment">// 将其改造成简单工厂模式</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JobFactory</span>(<span class="hljs-params">type,content</span>)</span>{
    <span class="hljs-keyword">switch</span>(type){
        <span class="hljs-keyword">case</span> <span class="hljs-string">'PHP'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PHP(content);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'Java'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Java(content)
    }
}

JobFactory(<span class="hljs-string">'PHP'</span>,<span class="hljs-string">'展示个东西看一眼'</span>)

<span class="hljs-comment">// 工厂方法模式本意是说将实际创建对象工作推迟到子类中。这样核心类就成了抽像类，可以将工厂方法堪称实例转化对象的工厂类别。我们采用安全模式类，我们将创建对象的基类放在工厂方法类的类别中。</span>
<span class="hljs-comment">// 安全模式是屏蔽使用这对类的错误使用造成的错误。</span>
<span class="hljs-keyword">var</span> Demo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// 安全模式</span>
    <span class="hljs-keyword">if</span>(!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Demo)){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Demo();
    }
}
Demo.prototype = {
    <span class="hljs-attr">show</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功获取'</span>);
    }
}

<span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Demo();
d.show();

<span class="hljs-keyword">var</span> e = Demo();
e.show();<span class="hljs-comment">// 这样就出错了，按照函数调用了</span>

<span class="hljs-comment">// 将安全模式应用到我们的工厂方法中，将类写的更稳妥</span>
<span class="hljs-comment">// 安全模式创建的工厂类</span>
<span class="hljs-keyword">var</span> Factory = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type,content</span>)</span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Factory){
        <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>[type](content);
        <span class="hljs-keyword">return</span> s;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Factory(type,content);
    }
}

<span class="hljs-comment">// 工厂原型中设置创建所有类型数据的对象积累</span>
Factory.prototype = {
    <span class="hljs-attr">Java</span> :<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
        <span class="hljs-keyword">this</span>.content = content;
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
            div.innerHTML = content;
            div.style.border = <span class="hljs-string">'1px solid red'</span>;
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>).appendChild(div);
        })(content);
    },
    <span class="hljs-attr">Javascript</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
        <span class="hljs-keyword">this</span>.content = content;
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
            div.innerHTML = content;
            div.style.border = <span class="hljs-string">'1px solid red'</span>;
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>).appendChild(div);
        })(content);
    },
    <span class="hljs-attr">PHP</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
        <span class="hljs-keyword">this</span>.content = content;
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
            div.innerHTML = content;
            div.style.border = <span class="hljs-string">'1px solid green'</span>;
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>).appendChild(div);
        })(content);
    },
    <span class="hljs-attr">UI</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
        <span class="hljs-keyword">this</span>.content = content;
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>)</span>{
            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
            div.innerHTML = content;
            div.style.border = <span class="hljs-string">'1px solid orange'</span>;
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>).appendChild(div);
        })(content);
    }
}

<span class="hljs-keyword">var</span> data = [
    {<span class="hljs-attr">type</span>:<span class="hljs-string">'Javascript'</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">'Javascript 学习班级'</span>},
    {<span class="hljs-attr">type</span>:<span class="hljs-string">'Java'</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">'Javascript 学习班级'</span>},
    {<span class="hljs-attr">type</span>:<span class="hljs-string">'PHP'</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">'Javascript 学习班级'</span>},
    {<span class="hljs-attr">type</span>:<span class="hljs-string">'UI'</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">'Javascript 学习班级'</span>},
    {<span class="hljs-attr">type</span>:<span class="hljs-string">'Javascript'</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">'Javascript 学习班级'</span>},
    {<span class="hljs-attr">type</span>:<span class="hljs-string">'Javascript'</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">'Javascript 学习班级'</span>},
    {<span class="hljs-attr">type</span>:<span class="hljs-string">'Javascript'</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">'Javascript 学习班级'</span>}
];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt;data.length ;i++){
    Factory(data[i].type,data[i].content)
}
</code></pre>
<h2 id="原始模型模式-prototype">原始模型模式 PROTOTYPE <a class="markdownIt-Anchor" href="#原始模型模式-prototype">#</a></h2>
<ol start="4">
<li>PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）</li>
</ol>
<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
<pre class="hljs"><code><span class="hljs-comment">// 原型模式（prototype）：用原型实例指向创建对象的类，适用于创建新的对象的类共享原型对象的属性以及方法。</span>
<span class="hljs-comment">// 实现机制是基于原型链实现对象之间的继承，这种继承是基于一种对属性或者方法的共享，而不是对属性和方法的复制。</span>

<span class="hljs-comment">// 举例 创建一个焦点图类</span>
<span class="hljs-comment">// 图片轮播类</span>
<span class="hljs-keyword">var</span> LoopImages = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">imgArr,container</span>)</span>{
    <span class="hljs-keyword">this</span>.imageArray = imgArr; <span class="hljs-comment">// 轮播图片数组</span>
    <span class="hljs-keyword">this</span>.container = container; <span class="hljs-comment">// 轮播图片容器</span>
    <span class="hljs-keyword">this</span>.createImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{} <span class="hljs-comment">//创建轮播图片</span>
    <span class="hljs-keyword">this</span>.changeImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{} <span class="hljs-comment">//切换下一张图片</span>
}

<span class="hljs-comment">// 一个页面中图片的切换是多样化的，有的上下切换，有的左右，有的渐隐，首先抽象出一个基类，让不同特效类去继承这个基类，对差异化的需求通过重写这些继承下来的属性或者方法解决。</span>
<span class="hljs-comment">// 上下切换</span>
<span class="hljs-keyword">var</span> FadeLoopImg = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">imgArr,container</span>)</span>{
    <span class="hljs-comment">// 构造函数继承图片轮播类</span>
    LoopImages.call(<span class="hljs-keyword">this</span>,imgArr,container);
    <span class="hljs-comment">// 重写继承的切换下一张图片方法</span>
    <span class="hljs-keyword">this</span>.changeImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'SlideLoopImg changeImage function'</span>)
    }
}
<span class="hljs-comment">//渐隐切换类</span>
<span class="hljs-keyword">var</span> FadeLoopImg = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">imgArr,container,arrow</span>)</span>{
    <span class="hljs-comment">// 构造函数继承图片轮播类</span>
    LoopImages.call(<span class="hljs-keyword">this</span>,imgArr,container);
    <span class="hljs-keyword">this</span>.arrow = arrow;
    <span class="hljs-comment">// 重写继承的切换下一张图片方法</span>
    <span class="hljs-keyword">this</span>.changeImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'FadeLoopImg changeImage function'</span>)
    }
}

<span class="hljs-comment">// 实例化一个渐隐切换图片类</span>
<span class="hljs-keyword">var</span> fadeImg = <span class="hljs-keyword">new</span> FadeLoopImg([
    <span class="hljs-string">'01.jpg'</span>,
    <span class="hljs-string">'02.jpg'</span>,
    <span class="hljs-string">'03.jpg'</span>
],<span class="hljs-string">'slide'</span>,[<span class="hljs-string">'left'</span>,<span class="hljs-string">'right'</span>])

fadeImg.changeImage();

<span class="hljs-comment">// 问题 ，每次子类继承都要创建一次父类，假如说父类的构造函数中创建时存在好多耗时较长的逻辑，或者每次初始化的时候都做一些重复性的工作，这样的性能消耗还是蛮大的。我们需要一种共享机制，这样每当创建基类时，对于每次创建的一些简单而又差异化的属性，我们可以放在构造函数中，而我们将一些消耗资源比较大的方法放到基类的原型中，这样就会避免很多不必要的消耗。，这也是原型模式的一个雏形。</span>

<span class="hljs-comment">// 图片轮播类</span>
<span class="hljs-keyword">var</span> LoopImages = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">imgArr,container</span>)</span>{
    <span class="hljs-keyword">this</span>.imagesArray = imgArr;
    <span class="hljs-keyword">this</span>.container = container;
}
<span class="hljs-comment">// 将复杂一些的业务放到 原型中</span>
LoopImages.prototype = {
    <span class="hljs-comment">// 创建轮播图片</span>
    createImage : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'LoopImages creatImage function'</span>)
    },
    <span class="hljs-comment">// 切换下一张图片</span>
    changeImage : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'LoopImages changeImage function'</span>)
    }
}

<span class="hljs-comment">//创建上下切换图片类</span>
<span class="hljs-keyword">var</span> SlideLoopImg = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">imgArr,container</span>)</span>{
    <span class="hljs-comment">// 构造函数继承图片轮播类</span>
    LoopImages.call(<span class="hljs-keyword">this</span>,imgArr,container)
}
<span class="hljs-comment">// 实例继承</span>
SlideLoopImg.prototype = <span class="hljs-keyword">new</span> LoopImages();

<span class="hljs-comment">// 重写继承的切换下一张图片方法</span>
SlideLoopImg.prototype.changeImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'SlideLoopImg changeImage function'</span>)
}
<span class="hljs-comment">//渐隐切换类</span>
<span class="hljs-keyword">var</span> FadeLoopImg = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">imgArr,container,arrow</span>)</span>{
    <span class="hljs-comment">// 构造函数继承</span>
    LoopImages.call(<span class="hljs-keyword">this</span>,imgArr,container);
    <span class="hljs-comment">// 切换箭头私有变量</span>
    <span class="hljs-keyword">this</span>.arrow = arrow;
}
<span class="hljs-comment">// 实例对象继承</span>
FadeLoopImg.prototype = <span class="hljs-keyword">new</span> LoopImages();
FadeLoopImg.prototype.changeImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'FadeLoopImg changeImage function'</span>);
}

LoopImages.prototype.getImageLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.imagesArray.length;
}
FadeLoopImg.prototype.getContainer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.container;
}
<span class="hljs-comment">// 测试用例</span>
<span class="hljs-comment">// 实例化一个渐隐切换图片类</span>
<span class="hljs-keyword">var</span> fadeImg2 = <span class="hljs-keyword">new</span> FadeLoopImg([
    <span class="hljs-string">'01.jpg'</span>,
    <span class="hljs-string">'02.jpg'</span>,
    <span class="hljs-string">'03.jpg'</span>
],<span class="hljs-string">'slide'</span>,[<span class="hljs-string">'left'</span>,<span class="hljs-string">'right'</span>])

<span class="hljs-built_in">console</span>.log(fadeImg2.container)
fadeImg2.changeImage();

<span class="hljs-comment">// 原型对象的特点，原型是被共享的，无论子类修改原型还是父类修改原型，都是一个指向引用，所以原型对象才会被共享。对原型对象的拓展，不论是子类或者父类的实例对象都会继承下来。</span>


<span class="hljs-built_in">console</span>.log(fadeImg2.getImageLength());
<span class="hljs-built_in">console</span>.log(fadeImg2.getContainer());


<span class="hljs-comment">// 原型的继承</span>
<span class="hljs-comment">/*
    基于已存在的模版对象克隆出新对象的模式
    arguments[0],arguments[1],arguments[2]:参数
    这里对模版引用类型的属性实质上进行了浅复制（引用类型属性共享），当然根据需求可以自行深复制（引用类型属性复制）

*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prototypeExtend</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},
        args = <span class="hljs-built_in">arguments</span>,
        i = <span class="hljs-number">0</span>,
        len = args.length;
    <span class="hljs-keyword">for</span>(;i&lt;len;i++){
        <span class="hljs-comment">//遍历每个模版对象中的属性</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j <span class="hljs-keyword">in</span> args[i]){
            <span class="hljs-comment">// 将这些属性复制到缓存类原型中</span>
            F.prototype[j] = args[i][j];
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();
}

<span class="hljs-comment">// 比如企鹅游戏汇总我们创建一个企鹅对象，如果游戏中没有企鹅基类，只是提供了一些工作模版对象，我们可以通过实现对这些模版对象的继承来创建一个企鹅实例对象。</span>
<span class="hljs-keyword">var</span> Penguim = prototypeExtend({
    <span class="hljs-attr">speed</span>:<span class="hljs-number">20</span>,
    <span class="hljs-attr">swim</span> :<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'游泳速度'</span> + <span class="hljs-keyword">this</span>.speed);
    }
},{
    <span class="hljs-attr">run</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">speed</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'奔跑速度'</span> +speed);
    }
},{
    <span class="hljs-attr">jump</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'跳跃动作'</span>)
    }
})

Penguim.swim(); <span class="hljs-comment">//游泳速度 20</span>
Penguim.run(<span class="hljs-number">10</span>); <span class="hljs-comment">// 跑步速度 10</span>
Penguim.jump(); <span class="hljs-comment">// 跳跃动作</span>
<span class="hljs-comment">// 将一些模版合成一个对象</span>
</code></pre>
<h2 id="单例模式-singleton">单例模式 SINGLETON <a class="markdownIt-Anchor" href="#单例模式-singleton">#</a></h2>
<ol start="5">
<li>SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)</li>
</ol>
<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
<pre class="hljs"><code><span class="hljs-comment">// 单例模式（singleton）:又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条的管理对象上的属性与方法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params">id</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.getElementById(id)
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">css</span>(<span class="hljs-params">id,key,value</span>)</span>{
    <span class="hljs-comment">//简单样式属性设置</span>
    g(id).style[key] = value;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attr</span>(<span class="hljs-params">id,key,value</span>)</span>{
    g(id)[key] = value;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">html</span>(<span class="hljs-params">id,value</span>)</span>{
    g(id).innerHTML = value;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span>(<span class="hljs-params">id,type,fn</span>)</span>{
    g(id)[<span class="hljs-string">'on'</span> + type] = fn;
}

<span class="hljs-comment">// 当别人重定义on 事件的时候会产生冲突，用名字空间包裹起来</span>
<span class="hljs-keyword">var</span> Ming = {
    <span class="hljs-attr">g</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.getElementById(id);
    },
    <span class="hljs-attr">css</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>)</span>{
        <span class="hljs-keyword">this</span>.g(id).style[key] = value;
    },
    <span class="hljs-attr">attr</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>)</span>{
        <span class="hljs-keyword">this</span>.g(id)[key] = value;
    },
    <span class="hljs-attr">html</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id,value</span>)</span>{
        <span class="hljs-keyword">this</span>.g(id).innerHTML = value;
    },
    <span class="hljs-attr">on</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id,type,fn</span>)</span>{
        <span class="hljs-keyword">this</span>.g(id)[<span class="hljs-string">'on'</span> + type] = fn;
    }
}
Ming.html(<span class="hljs-string">'test'</span>,<span class="hljs-string">'换一句话'</span>);
Ming.on(<span class="hljs-string">'test'</span>,<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
    alert(<span class="hljs-string">'弹出一条消息'</span>);
})
</code></pre>
<h1 id="结构型模式">结构型模式 <a class="markdownIt-Anchor" href="#结构型模式">#</a></h1>
<h2 id="适配器-adapter">适配器 ADAPTER <a class="markdownIt-Anchor" href="#适配器-adapter">#</a></h2>
<ol start="6">
<li>ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)</li>
</ol>
<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mybutton"</span>&gt;</span> 这里大概显示一个按钮 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcss.com/jquery/3.2.1/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-comment">// 适配器模式时（Adapter）：讲一个类（对象）的接口（方法或者属性）转化成另一个接口，以满足用户需求，使类（对象）之间的接口的不兼容问题通过适配器得以解决。</span>
<span class="hljs-comment">// 适配器的意义，加载jquery后写一个适配器。将我们已有的功能适配到 jQuery 。比如页面有两个事件，一个页面加载事件，一个点击事件。这两个事件与jquery写法很像，所以这里就不用做多少改动了。我们的适配器主要的任务是适配两种代码库中不兼容的代码，首当其冲的就是全局对象 A 与 jQuery 了，所以你可以像下面这样轻松实现。</span>
<span class="hljs-built_in">window</span>.A = A = jQuery;
<span class="hljs-keyword">var</span> A = A || {};
A.g = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id,type,fn</span>)</span>{
    <span class="hljs-comment">//return document.getElementById(id);</span>
    <span class="hljs-comment">// 将通过 id 获取的方法通过 $('id')获取</span>
    <span class="hljs-keyword">return</span> $(id).get(<span class="hljs-number">0</span>);
}
A.on= <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id,type,fn</span>)</span>{
    <span class="hljs-comment">// 如果传递参数是字符串则以 id 处理，否则以元素对象处理</span>
    <span class="hljs-comment">// var dom = typeof id === 'string' ? this.g(id) : id;</span>
    <span class="hljs-comment">// 标准 dom2级添加事件</span>
    <span class="hljs-comment">// if(dom.addEvenetListener){</span>
    <span class="hljs-comment">//     dom.addEvenetListener(type,fn,false);</span>
    <span class="hljs-comment">// }else if(dom.attachEvent){</span>
    <span class="hljs-comment">//     dom.attachEvent('on' + type, fn)</span>
    <span class="hljs-comment">// }else{</span>
    <span class="hljs-comment">//     dom['on' + type] = fn;</span>
    <span class="hljs-comment">// }</span>

    <span class="hljs-comment">// 用jquery 库改造</span>
    <span class="hljs-keyword">var</span> dom = <span class="hljs-keyword">typeof</span> id ===<span class="hljs-string">'string'</span> ? $(<span class="hljs-string">'#'</span> + id) : $(id);
    dom.on(type,fn);
}
A.on(<span class="hljs-built_in">window</span>,<span class="hljs-string">'load'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// 按钮点击事件</span>
    A.on(<span class="hljs-string">'mybutton'</span>,<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'do something'</span>);
    })
})

<span class="hljs-comment">// 参数适配器</span>
<span class="hljs-comment">/**
obj.name : name
obj.title : title
obj.age : age
obj.color : color
**/</span>
<span class="hljs-comment">// 当我们调用的时候，不知道传递的参数是否完整，如有一些必须参数没有传入，一些参数是有默认值的，此时我们通常的做法使用适配器来适配传入的这个参数对象。</span>

<span class="hljs-comment">// function doSomeThing(obj){</span>
<span class="hljs-comment">//     var _adapter= {</span>
<span class="hljs-comment">//         name:'雨夜清荷',</span>
<span class="hljs-comment">//         title :''</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// }</span>

<span class="hljs-keyword">var</span> arr = [<span class="hljs-string">'JavaScript'</span>,<span class="hljs-string">'book'</span>,<span class="hljs-string">'前端编程语言'</span>,<span class="hljs-string">'8月1日'</span>];
<span class="hljs-comment">// 用数组的形式，每个成员代表的意义不同，所以这种数据结构语义不好，我们通常会将其适配成对象形式，比如下面这种对象数据结构。</span>
<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>,
    <span class="hljs-attr">type</span> : <span class="hljs-string">''</span>,
    <span class="hljs-attr">title</span> : <span class="hljs-string">''</span>,
    <span class="hljs-attr">time</span> : <span class="hljs-string">''</span>
}
<span class="hljs-comment">// 写一个适配器</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrToObjAdapter</span>(<span class="hljs-params">arr</span>)</span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">name</span> : arr[<span class="hljs-number">0</span>],
        <span class="hljs-attr">type</span> : arr[<span class="hljs-number">1</span>],
        <span class="hljs-attr">title</span> : arr[<span class="hljs-number">2</span>],
        <span class="hljs-attr">time</span> : arr[<span class="hljs-number">3</span>]
    }
}
<span class="hljs-keyword">var</span> adapterData = arrToObjAdapter(arr)
<span class="hljs-built_in">console</span>.log(adapterData);

<span class="hljs-comment">// 服务器端数据适配</span>
<span class="hljs-comment">// 前端程序不再为后端传递的数据所束缚，如果后端因框架改变导致传递的数据结构发生变化，我们只需要写个适配器就可以放心了。比如用 jQuery 向后端 someAdress.php 接口请求数据，然后用 dosomething 方法处理接受的数据。后端有时无法控制数据的格式，我们在调用 dosomething 方法时最好不要直接调用，先将传递过来的数据适配成我们需要的数据再使用，更加安全。</span>

<span class="hljs-comment">// 简化模型，这里使用 jQuery 的 ajax 方法，理想数据是一个一维数组</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajaxAdapter</span>(<span class="hljs-params">data</span>)</span>{
    <span class="hljs-comment">// 处理数据并返回新数据</span>
    <span class="hljs-keyword">return</span> [data[<span class="hljs-string">'key1'</span>],data[<span class="hljs-string">'key2'</span>],data[<span class="hljs-string">'key3'</span>],data[<span class="hljs-string">'key4'</span>]];
}
$.ajax({
    <span class="hljs-attr">url</span> : <span class="hljs-string">'someAddress.php'</span>,
    <span class="hljs-attr">success</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data,status</span>)</span>{
        <span class="hljs-comment">// 像这样，如果日后后端数据有任何变化，我们只需要相应的更改 ajaxAdapter 适配器转换格式就可以。</span>
        ajaxAdapter(data);
    }
})
</code></pre>
<ol start="7">
<li>BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了</li>
</ol>
<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<pre class="hljs"><code><span class="hljs-comment">// 第一步，提取共同点</span>
<span class="hljs-comment">// 对相同的逻辑做抽象提取处理，让代码简介，重用率提升。比如他们都处理每个原件中的某个元素，比如他们都会是处理每个部件中的某个元素，都会处理该元素的字体颜色和背景色。对相似点的抽象提取是很有必要的，因此你可以创建下面这样一个函数，让它接触与事件中的this的耦合。</span>

<span class="hljs-comment">// 抽象</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span>(<span class="hljs-params">dom,color,bg</span>)</span>{
    <span class="hljs-comment">// 设置元素的字体颜色</span>
    dom.style.color = color;
    <span class="hljs-comment">// 设置元素的背景颜色</span>
    dom.style.bg = bg;
}

<span class="hljs-comment">// 事件与业务逻辑之间的桥梁</span>
<span class="hljs-comment">// 知道元素绑定事件与抽象提取的设置方式方法 changeColor 还是不够，需要用一个方法将他们链接起来。这个方法就是桥接方法，这种模式就是桥接模式。对于事件的桥接方法，我们可以使用一个匿名函数来代替，否则直接将 changeColor 作为事件的回调函数，那么我们刚才所做的事情就白做了，因为它们还将耦合在一起。</span>

<span class="hljs-keyword">var</span> spans = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'span'</span>);
spans[<span class="hljs-number">0</span>].onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    changeColor(<span class="hljs-keyword">this</span>,<span class="hljs-string">'#333'</span>,<span class="hljs-string">'#666'</span>);
}
<span class="hljs-comment">// 它的成本是新增一个桥接函数。</span>
<span class="hljs-comment">// 桥接模式对于多位的变化也适用。比如我们书写一个 canvas 跑步游戏的时候，对于游戏中的人、小精灵、小球都有动作但愿，每个动作实现起来方式又都是统一的，这样我们可以将这些多维变化提取出来，当我们创建实体时，将需要的每个抽象动作单元通过桥接，链接在一起运作，他们之间不会相互影响并且降低了它们之间的耦合。</span>
<span class="hljs-comment">// 多维变量类</span>
<span class="hljs-comment">// 运动</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Speed</span>(<span class="hljs-params">x,y</span>)</span>{
    <span class="hljs-keyword">this</span>.x = x;
    <span class="hljs-keyword">this</span>.y = y;
}
Speed.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'运动起来'</span>);
}
<span class="hljs-comment">// 着色</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Color</span>(<span class="hljs-params">cl</span>)</span>{
    <span class="hljs-keyword">this</span>.color = cl;
}
Color.prototype.draw = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'绘制色彩'</span>);
}

<span class="hljs-comment">// 我们创建一个球类，让她运动 着色</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ball</span>(<span class="hljs-params">x,y,c</span>)</span>{
    <span class="hljs-keyword">this</span>.speed = <span class="hljs-keyword">new</span> Speed(x,y);
    <span class="hljs-keyword">this</span>.color = <span class="hljs-keyword">new</span> Color(c);
}
Ball.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// 实现运动</span>
    <span class="hljs-keyword">this</span>.speed.run();
    <span class="hljs-comment">// 实现着色</span>
    <span class="hljs-keyword">this</span>.color.draw();
}
<span class="hljs-comment">// 创建一个人</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">x,y,c</span>)</span>{
    <span class="hljs-keyword">this</span>.speed = <span class="hljs-keyword">new</span> Speed(x,y);
    <span class="hljs-keyword">this</span>.color = <span class="hljs-keyword">new</span> Color(c);
}
People.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// 实现运动</span>
    <span class="hljs-keyword">this</span>.speed.run();
    <span class="hljs-comment">// 实现着色</span>
    <span class="hljs-keyword">this</span>.color.draw();
}

<span class="hljs-comment">// 实例化</span>
<span class="hljs-keyword">var</span> ball = <span class="hljs-keyword">new</span> Ball(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-string">'#333'</span>);
<span class="hljs-keyword">var</span> people = <span class="hljs-keyword">new</span> People(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-string">'#333'</span>);
</code></pre>
<ol start="8">
<li>COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？</li>
</ol>
<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<pre class="hljs"><code><span class="hljs-comment">// 合成模式又称为部分整体模式，将对象组合成树形结构以表示‘部分整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</span>
<span class="hljs-comment">// 在此用一个新闻列表举例子，新闻列表有文字新闻、带直播图标的新闻、包含分类的文字新闻、图片新闻、图片和文字组合的新闻</span>
<span class="hljs-comment">// 将新闻氛围相互独立的几种类型，对某类新闻修改时不会影响到其它。将每一类新闻抽象称面向对象编程中的一个类，这样不会担心以后对某类新闻需求修改而影响到其他新闻，只需对这类新闻做相应的修改即可。抽象类类组合来满足需求。先抽象拆解再组合。</span>
<span class="hljs-comment">// 统一接口，就是每个成员都要又祖先</span>
<span class="hljs-comment">// 接口统一在javascript 下可以通过继承同一个虚拟类来实现，比如这个需求可以让所有的新闻都继承一个新闻虚拟父类 News。</span>
<span class="hljs-comment">// 原型继承</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritObject</span>(<span class="hljs-params">o</span>)</span>{
    <span class="hljs-comment">// 声明一个过渡函数对象</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>)</span>{};
    <span class="hljs-comment">// 过渡对象的原型继承父对象</span>
    F.prototype = o;
    <span class="hljs-comment">// 返回过渡对象的实例</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();
}
<span class="hljs-comment">// 寄生继承</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">subClass, superClass</span>) </span>{
    <span class="hljs-comment">// 复制一份父类的原型副本保存在变量中</span>
    <span class="hljs-keyword">var</span> p = inheritObject( superClass.prototype );
    <span class="hljs-comment">// 修正因为重写子类原型导致子类的 constructor 属性被修改</span>
    p.constructor = subClass;
    <span class="hljs-comment">// 设置子类的原型</span>
    subClass.prototype = p;
}

<span class="hljs-keyword">var</span> News = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// 子组件容器</span>
    <span class="hljs-keyword">this</span>.children = [];
    <span class="hljs-comment">// 当前组件元素</span>
    <span class="hljs-keyword">this</span>.element = <span class="hljs-literal">null</span>;
}
News.prototype = {
    <span class="hljs-attr">init</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'请重写方法'</span>);
    },
    <span class="hljs-attr">add</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'请重写方法'</span>);
    },
    <span class="hljs-attr">getElement</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'请重写方法'</span>);
    }
}
<span class="hljs-comment">// 通常虚拟类是定义而不实现的，但我们在虚拟类的构造函数中定义两个特权变量是因为后面的所有继承子类都要声明这两个变量，为了简化子类我们也可以将这些共有的变量提前声明在父类中。</span>
<span class="hljs-comment">// 在实现过程中要注意他们的层次关系，组合模式不仅仅是单层次组合，也可以是一个多层次的，比如实现图片新闻和文字新闻放在一行的条件就是说，我们将组合后的整体作为一个部分，继续组合。这样就需要在拆分整体后还要确定他们的层次关系，比如最顶层是一个新闻模块的容器，再往下面是每一行新闻成员集合，每一行还可能有新闻组合体，当然最后一层组合体里面的成员就是新闻对象。</span>


<span class="hljs-comment">// 组合要有容器类,在此用到寄生组合模式</span>
<span class="hljs-comment">// 容器类构造函数</span>
<span class="hljs-keyword">var</span> Container = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id,parent</span>)</span>{
    <span class="hljs-comment">// 构造函数继承类</span>
    News.call(<span class="hljs-keyword">this</span>);
    <span class="hljs-comment">// 模块id</span>
    <span class="hljs-keyword">this</span>.id = id;
    <span class="hljs-comment">// 模块的父容器</span>
    <span class="hljs-keyword">this</span>.parent = parent;
    <span class="hljs-comment">// 构建方法</span>
    <span class="hljs-keyword">this</span>.init();
}
<span class="hljs-comment">// 寄生式继承父类原型方法</span>
inheritPrototype(Container, News);
<span class="hljs-comment">// 构建方法</span>
Container.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'ul'</span>);
    <span class="hljs-keyword">this</span>.element.id = <span class="hljs-keyword">this</span>.id;
    <span class="hljs-keyword">this</span>.element.className = <span class="hljs-string">'new-container'</span>;
}
<span class="hljs-comment">// 添加子元素方法</span>
Container.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>)</span>{
    <span class="hljs-comment">// 在子元素容器中插入子元素</span>
    <span class="hljs-keyword">this</span>.children.push(child);
    <span class="hljs-comment">// 插入当前组件元素树中</span>
    <span class="hljs-keyword">this</span>.element.appendChild(child.getElement());
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
<span class="hljs-comment">// 获取当前元素方法</span>
Container.prototype.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element;
}
<span class="hljs-comment">// 显示方法</span>
Container.prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.parent.appendChild(<span class="hljs-keyword">this</span>.element);
}
<span class="hljs-comment">// 下一级的行成员集合类以及后面的新闻组合体类实现的方式与之类似</span>
<span class="hljs-keyword">var</span> Item = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">classname</span>)</span>{
    News.call(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.classname = classname || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>.init();
}
inheritPrototype(Item,News);
Item.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'li'</span>);
    <span class="hljs-keyword">this</span>.element.classname = <span class="hljs-keyword">this</span>.classname;
}
Item.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>)</span>{
    <span class="hljs-comment">// 在子元素容器中插入子元素</span>
    <span class="hljs-keyword">this</span>.children.push(child);
    <span class="hljs-comment">// 插入当前组件树中</span>
    <span class="hljs-keyword">this</span>.element.appendChild(child.getElement());
}

Item.prototype.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element;
}
Item.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>)</span>{
    <span class="hljs-comment">// 在子元素中插入子元素</span>
    <span class="hljs-keyword">this</span>.children.push(child);
    <span class="hljs-comment">// 插入当前组件元素树中</span>
    <span class="hljs-keyword">this</span>.element.appendChild(child.getElement());
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
Item.prototype.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element;
}

<span class="hljs-keyword">var</span> NewsGroup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">classname</span>)</span>{
    News.call(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.classname = classname || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>.init();
}
inheritPrototype(NewsGroup,News);
NewsGroup.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
    <span class="hljs-keyword">this</span>.element.classname = <span class="hljs-keyword">this</span>.classname;
}
NewsGroup.prototype.add =<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>)</span>{
    <span class="hljs-comment">// 在子元素容器中插入子元素</span>
    <span class="hljs-keyword">this</span>.children.push(child);
    <span class="hljs-comment">// 插入当前组件元素树中</span>
    <span class="hljs-keyword">this</span>.element.appendChild(child.getElement());
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
NewsGroup.prototype.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element;
}

<span class="hljs-comment">// 上面已经把所有子成员创建出来了，但是都是容器，还需要更底层的新闻类，这些新闻成员类是不能拥有子成员的，但是他们继承了父类，所以对 add 方法需要声明一下</span>

<span class="hljs-keyword">var</span> ImageNews = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url,href,classname</span>)</span>{
    News.call(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.url = url || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>.href = url || <span class="hljs-string">'#'</span>;
    <span class="hljs-keyword">this</span>.classname = classname || <span class="hljs-string">'normal'</span>;
    <span class="hljs-keyword">this</span>.init();
}
inheritPrototype(ImageNews,News);
ImageNews.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>);
    <span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();
    img.src = <span class="hljs-keyword">this</span>.url;
    <span class="hljs-keyword">this</span>.element.appendChild(img);
    <span class="hljs-keyword">this</span>.element.classname = <span class="hljs-string">'image-news '</span> + <span class="hljs-keyword">this</span>.classname;
    <span class="hljs-keyword">this</span>.element.href = <span class="hljs-keyword">this</span>.href;
}
ImageNews.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
ImageNews.prototype.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element;
}
<span class="hljs-comment">// 新闻类与上面的容器类很像，接下来创建其他基类新闻</span>
<span class="hljs-keyword">var</span> IconNews = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text,href,type</span>)</span>{
    News.call(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.text = text || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>.href = href || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>.type = type || <span class="hljs-string">'Video'</span>;
    <span class="hljs-keyword">this</span>.init();
}
inheritPrototype(IconNews,News);
IconNews.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>);
    <span class="hljs-keyword">this</span>.element.innerHTML = <span class="hljs-keyword">this</span>.text;
    <span class="hljs-keyword">this</span>.element.href = <span class="hljs-keyword">this</span>.href;
    <span class="hljs-keyword">this</span>.element.className = <span class="hljs-string">'icon'</span> + <span class="hljs-keyword">this</span>.type;
}
IconNews.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}
IconNews.prototype.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element;
}

<span class="hljs-keyword">var</span> EasyNews = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text,href</span>)</span>{
    News.call(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.text = text || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>.href = href || <span class="hljs-string">'#'</span>;
    <span class="hljs-keyword">this</span>.init();
}
inheritPrototype(EasyNews,News);
EasyNews.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>);
    <span class="hljs-keyword">this</span>.element.innerHTML = <span class="hljs-keyword">this</span>.text;
    <span class="hljs-keyword">this</span>.element.href = <span class="hljs-keyword">this</span>.href;
    <span class="hljs-keyword">this</span>.element.className = <span class="hljs-string">'text'</span>;
}
EasyNews.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}
EasyNews.prototype.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element;
}

<span class="hljs-keyword">var</span> TypeNews = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text,href,type,pos</span>)</span>{
    News.call(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.text = text || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>.href = href || <span class="hljs-string">'#'</span>;
    <span class="hljs-keyword">this</span>.type = type || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>.pos = pos || <span class="hljs-string">'left'</span>;
    <span class="hljs-keyword">this</span>.init();
}
inheritPrototype(TypeNews,News);
TypeNews.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>);
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.pos === <span class="hljs-string">'left'</span>){
        <span class="hljs-keyword">this</span>.element.innerHTML = <span class="hljs-string">'['</span> + <span class="hljs-keyword">this</span>.type + <span class="hljs-string">']'</span> + <span class="hljs-keyword">this</span>.text;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">this</span>.element.innerHTML = <span class="hljs-keyword">this</span>.text + <span class="hljs-string">'['</span> + <span class="hljs-keyword">this</span>.type + <span class="hljs-string">']'</span>;
    }
    <span class="hljs-keyword">this</span>.element.href = <span class="hljs-keyword">this</span>.href;
    <span class="hljs-keyword">this</span>.element.className = <span class="hljs-string">'text'</span>;
}
TypeNews.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}
TypeNews.prototype.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element;
}
<span class="hljs-comment">// 把新闻模块创建出来</span>
<span class="hljs-keyword">var</span> news1 = <span class="hljs-keyword">new</span> Container(<span class="hljs-string">'news'</span>,<span class="hljs-built_in">document</span>.body);
news1.add(
    <span class="hljs-keyword">new</span> Item(<span class="hljs-string">'normal'</span>).add(
        <span class="hljs-keyword">new</span> IconNews(<span class="hljs-string">'一条新闻'</span>,<span class="hljs-string">'#'</span>,<span class="hljs-string">'video'</span>)
    )
).add(
    <span class="hljs-keyword">new</span> Item(<span class="hljs-string">'normal'</span>).add(
        <span class="hljs-keyword">new</span> IconNews(<span class="hljs-string">'这是一条普通新闻'</span>,<span class="hljs-string">'#'</span>,<span class="hljs-string">'video'</span>)
    )
).add(
    <span class="hljs-keyword">new</span> Item(<span class="hljs-string">'normal'</span>).add(
        <span class="hljs-keyword">new</span> NewsGroup(<span class="hljs-string">'has-img'</span>).add(
            <span class="hljs-keyword">new</span> ImageNews(<span class="hljs-string">'./1.jpg'</span>,<span class="hljs-string">'#'</span>,<span class="hljs-string">'small'</span>)
        ).add(
            <span class="hljs-keyword">new</span> EasyNews(<span class="hljs-string">'瘦身成功'</span>,<span class="hljs-string">'#'</span>)
        ).add(
            <span class="hljs-keyword">new</span> EasyNews(<span class="hljs-string">'瘦身成功'</span>,<span class="hljs-string">'#'</span>)
        )
    )
).add(
    <span class="hljs-keyword">new</span> Item(<span class="hljs-string">'normal'</span>).add(
        <span class="hljs-keyword">new</span> NewsGroup(<span class="hljs-string">'has-img'</span>).add(
            <span class="hljs-keyword">new</span> ImageNews(<span class="hljs-string">'./1.jpg'</span>,<span class="hljs-string">'#'</span>,<span class="hljs-string">'small'</span>)
        ).add(
            <span class="hljs-keyword">new</span> EasyNews(<span class="hljs-string">'瘦身成功'</span>,<span class="hljs-string">'#'</span>)
        ).add(
            <span class="hljs-keyword">new</span> EasyNews(<span class="hljs-string">'瘦身成功'</span>,<span class="hljs-string">'#'</span>)
        )
    )
).add(
    <span class="hljs-keyword">new</span> Item(<span class="hljs-string">'normal'</span>).add(
        <span class="hljs-keyword">new</span> ImageNews(<span class="hljs-string">'./1.jpg'</span>,<span class="hljs-string">'#'</span>,<span class="hljs-string">'small'</span>)
    ).add(
        <span class="hljs-keyword">new</span> EasyNews(<span class="hljs-string">'减肥成功'</span>,<span class="hljs-string">'#'</span>)
    ).add(
        <span class="hljs-keyword">new</span> EasyNews(<span class="hljs-string">'跑步机'</span>,<span class="hljs-string">'#'</span>)
    )
).add(
    <span class="hljs-keyword">new</span> Item(<span class="hljs-string">'normal'</span>).add(
        <span class="hljs-keyword">new</span> TypeNews(<span class="hljs-string">'AK47打球'</span>,<span class="hljs-string">'#'</span>,<span class="hljs-string">'NBA'</span>,<span class="hljs-string">'left'</span>)
    )
).show();
</code></pre>
<ol start="9">
<li>DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</li>
</ol>
<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
<pre class="hljs"><code><span class="hljs-comment">// 装饰者模式（Decorator）: 在不改变原对象的基础上，通过对其进行包装拓展（添加属性或者方法）使原有对象可以满足用户的更复杂的需求。</span>

<span class="hljs-comment">// 装饰已有的功能对象</span>

<span class="hljs-keyword">var</span> decorator = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input, fn</span>)</span>{
    <span class="hljs-comment">// 获取事件源</span>
    <span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.getElementById(input);
    <span class="hljs-comment">// 若事件源已经绑定事件</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> input.onclick === <span class="hljs-string">'function'</span>){
        <span class="hljs-comment">// 缓存事件源原有的回调函数</span>
        <span class="hljs-keyword">var</span> oldClick = input.onclick;
        input.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">// 事件源原有函数调用</span>
        oldClick();
        <span class="hljs-comment">//执行事件源新增回调函数</span>
        fn();
        }
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-comment">// 事件源未绑定事件，直接为事件源添加新增回调函数</span>
        input.onclick = fn
    }
}

<span class="hljs-comment">// 可以像下面这样执行</span>
decorator(<span class="hljs-string">'tel_input'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'tel_demo_text'</span>).style.display = <span class="hljs-string">'none'</span>;
})
</code></pre>
<ol start="10">
<li>FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。</li>
</ol>
<p>门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myinput"</span>&gt;</span>看看这里<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box"</span>&gt;</span>看看这里<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-comment">// 外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在javascript 中有时也会用与对底层结构兼容性做统一的封装来简化用户使用。</span>

<span class="hljs-comment">// 添加一个点击事件，在 document 对象上绑定一个 click 事件来实现隐藏提示框的交互功能，直接用 onclick 为 document 绑定事件，问题是 onclick  是 DOM0 级事件，会相互覆盖，因此我们需要有一个兼容方法。</span>

<span class="hljs-comment">// 用 DOM2 级事件处理程序提供的方法 addEventListener 来实现，低于 IE9 不支持，所以用用 attachEvent ,不支持的也只能用 onclick 事件方法绑定事件。</span>

<span class="hljs-comment">// 外观模式实现</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">dom,type,fn</span>)</span>{
    <span class="hljs-comment">// 对于支持 DOM2 级事件处理程序 addEventListener 方法的浏览器</span>
    <span class="hljs-keyword">if</span>(dom.addEventListener){
        dom.addEventListener(type,fn,<span class="hljs-literal">false</span>);
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dom.attachEvent){
        dom.attachEvent(<span class="hljs-string">'on'</span> + type,fn);
    }<span class="hljs-keyword">else</span>{
        dom[<span class="hljs-string">'on'</span> + type ] = fn;
    }
}

<span class="hljs-comment">// 可以放心的绑定事件了</span>
<span class="hljs-keyword">var</span> myinput = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'myinput'</span>);

addEvent(myinput,<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'绑定第一个事件'</span>);
});
addEvent(myinput,<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'绑定第二个事件'</span>);
});
addEvent(myinput,<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'绑定第三个事件'</span>);
});

<span class="hljs-comment">// 外观模式 1。简化底层接口复杂性 2。解决浏览器兼容性问题</span>

<span class="hljs-comment">// IE 低版本浏览器中不兼容 e.preventDefault() 和 e.target,可以通过外观模式来解决</span>

<span class="hljs-comment">// 获取事件对象</span>
<span class="hljs-keyword">var</span> getEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{
    <span class="hljs-comment">// 标准浏览器下放回 event，IE 下 window.event</span>
    <span class="hljs-keyword">return</span> event || <span class="hljs-built_in">window</span>.event;
}
<span class="hljs-comment">// 获取元素</span>
<span class="hljs-keyword">var</span> getTarget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{
    <span class="hljs-keyword">var</span> event = getEvent(event);
    <span class="hljs-comment">// 标准浏览器下 event.target,IE 下 event.srcElement</span>
    <span class="hljs-keyword">return</span> event.target || event.srcElement;
}
<span class="hljs-comment">// 组织默认行为</span>
<span class="hljs-keyword">var</span> preventDefault = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{
    <span class="hljs-keyword">var</span> event = getEvent(event);
    <span class="hljs-comment">//标准浏览器</span>
    <span class="hljs-keyword">if</span>(event.preventDefault){
        event.preventDefault();
    <span class="hljs-comment">// IE 浏览器</span>
    }<span class="hljs-keyword">else</span>{
        event.returnValue = <span class="hljs-literal">false</span>;
    }
}

<span class="hljs-comment">// 解决兼容问题</span>
<span class="hljs-built_in">document</span>.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{
    <span class="hljs-comment">//阻止默认行为</span>
    preventDefault(e);
    <span class="hljs-comment">//获取事件源目标对象</span>
    <span class="hljs-keyword">if</span>(getTarget(e) !== <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'myinput'</span>)){
        <span class="hljs-comment">// 执行操作</span>

    }
}

<span class="hljs-comment">// 小型代码库，很多代码库都是用外观模式来封装的，简化底层操作方法。</span>
<span class="hljs-keyword">var</span> A = {
    <span class="hljs-comment">// 通过id 获取元素</span>
    g: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.getElementById(id);
    },
    <span class="hljs-comment">// 设置 css 属性</span>
    css: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id,key,value</span>)</span>{
        <span class="hljs-built_in">document</span>.getElementById(id).style[key] = value;
    },
    <span class="hljs-comment">// 设置元素的属性</span>
    attr:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id,key,value</span>)</span>{
        <span class="hljs-built_in">document</span>.getElementById(id)[key] = value;
    },
    <span class="hljs-attr">html</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id,html</span>)</span>{
        <span class="hljs-built_in">document</span>.getElementById(id).innerHTML = html;
    },
    <span class="hljs-comment">//为元素绑定事件</span>
    on:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id,type,fn</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'aa'</span>)
        <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">document</span>.getElementById(id);
        a.addEventListener(type,fn)
    }
}

<span class="hljs-comment">// 通过上面的代码库，操作元素属性更简单</span>
A.css(<span class="hljs-string">'box'</span>,<span class="hljs-string">'background'</span>,<span class="hljs-string">'red'</span>);
A.attr(<span class="hljs-string">'box'</span>,<span class="hljs-string">'className'</span>,<span class="hljs-string">'red'</span>);
A.on(<span class="hljs-string">'box'</span>,<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    A.css(<span class="hljs-string">'box'</span>,<span class="hljs-string">'height'</span>,<span class="hljs-string">'500px'</span>);
});

<span class="hljs-comment">// 在页面添加事件，在 javascript中是一件及其麻烦的使其你过，尤其在众多变现不一的浏览器中。通过外观模式可以简化我们的操作。</span>
<span class="hljs-comment">// 当一个复杂的系统提供一些列复杂的几口方法时，为系统的管理方便会造成接口方法的使用极其复杂。这在团队的多人开发中，撰写成本是很大的。对接口的二次封装隐藏其复杂性，简化其操作是一种很不错的实践。</span>
<span class="hljs-comment">// 外观模式是对接口方法的外层包装，以供上层代码调用。因此有时外观模式封装的接口方法不需要接口的具体实现，只需要按照接口规则使用即可。这也是对系统与客户（使用者）之间的一种松散耦合。使得系统与客户间不会因结构的变化而相互影响。</span>
</code></pre>
<ol start="11">
<li>FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。</li>
</ol>
<p>享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"next"</span>&gt;</span>下一页<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre class="hljs"><code>        <span class="hljs-comment">// 享元模式（Flyweight）： 运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。</span>

        <span class="hljs-comment">// 比如写下面的翻页效果</span>
        <span class="hljs-comment">// var dom = null, //缓存创建的新闻标题</span>
        <span class="hljs-comment">//     paper = 0,  //当前页数</span>
        <span class="hljs-comment">//     num = 5,    //每页显示新闻数目</span>
        <span class="hljs-comment">//     i = 0,      //创建新闻元素时保存变量</span>
        <span class="hljs-comment">//     len = articel.length;   //新闻长度数据</span>
        <span class="hljs-comment">// for(; i&lt;len ; i++){</span>
        <span class="hljs-comment">//     dom = document.createElement('div');</span>
        <span class="hljs-comment">//     dom.innerHTML = articel[i];</span>
        <span class="hljs-comment">//     if(i &gt;= 5){</span>
        <span class="hljs-comment">//         dom.style.display = 'none';</span>
        <span class="hljs-comment">//     }</span>
        <span class="hljs-comment">//     document.getElementById('container').appendChild(dom);</span>
        <span class="hljs-comment">// }</span>
        <span class="hljs-comment">// // 下一页绑定事件</span>
        <span class="hljs-comment">// document.getElementById('next_page').onclick = function(){</span>
        <span class="hljs-comment">//     var div = document.getElementById('container').getElementsByTagName('div');</span>
        <span class="hljs-comment">//     // 获取所有新闻包装元素</span>
        <span class="hljs-comment">//     j = k = n = 0; // j,k 循环变量，n 当前页显示的第一个新闻序号</span>
        <span class="hljs-comment">//     n = ++paper % Math.ceil(len / num) * num; //获取当前页显示的第一个新闻序号</span>
        <span class="hljs-comment">//     for(;j&lt;len;j++){</span>
        <span class="hljs-comment">//         div[j].style.display = 'none';</span>
        <span class="hljs-comment">//     }</span>
        <span class="hljs-comment">//     for(;k&lt;5;k++){</span>
        <span class="hljs-comment">//         if(div[n + k]){</span>
        <span class="hljs-comment">//             div[n + k].style.display = 'block'; // 显示当前新闻</span>
        <span class="hljs-comment">//         }</span>
        <span class="hljs-comment">//     }</span>
        <span class="hljs-comment">// }</span>
        <span class="hljs-comment">// 思路是将所有的新闻都推到 dom 里面，通过显示隐藏控制</span>
        <span class="hljs-comment">// 问题是严重的性能问题，需要对相同的数据结构进行提取</span>
        <span class="hljs-comment">// 享元模式主要是对其数据、方法共享分离，他将数据和方法氛围内部数据、内部方法和外部数据、外部方法</span>
        <span class="hljs-comment">// 内部方法和内部数据指的是相似或者共有的数据和方法，</span>
        <span class="hljs-comment">/*
            将这一部分提取出来减少开销，提升性能
            像上面的情况，新闻个体有共同的结构，所以他们应该作为内部数据，
            下一页 按钮绑定的事件已经不能再抽象提取了，所以应该是外部的方法。
            既然内部的方法都提取出来了，为了能使用它们，我们还需要提供一个操作方法。
        */</span>
        <span class="hljs-keyword">var</span> Flyweight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-comment">// 已创建的元素</span>
            <span class="hljs-keyword">var</span> created = [];
            <span class="hljs-comment">// 创建一个新闻包装容器</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span>{
                <span class="hljs-keyword">var</span> dom = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
                <span class="hljs-comment">// 将容器插入新闻列表容器中</span>
                <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>).appendChild(dom);
                <span class="hljs-comment">// 缓存新创建的元素</span>
                created.push(dom);
                <span class="hljs-comment">// 返回创建的新元素</span>
                <span class="hljs-keyword">return</span> dom;
            }
            <span class="hljs-keyword">return</span> {
                <span class="hljs-comment">// 获取创建新闻元素方法</span>
                getDiv : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
                    <span class="hljs-comment">// 如果已创建的元素小于当前页元素总个数，则创建</span>
                    <span class="hljs-keyword">if</span>(created.length &lt; <span class="hljs-number">5</span>){
                        <span class="hljs-keyword">return</span> create();
                    }<span class="hljs-keyword">else</span>{
                        <span class="hljs-comment">// 获取第一个元素，并插入最后面</span>
                        <span class="hljs-keyword">var</span> div = created.shift();
                        created.push(div);
                        <span class="hljs-keyword">return</span> div;
                    }
                }
            }
        }();
        <span class="hljs-comment">/*
         创建一个享元类，由于每页显示 5条新闻，
         所以我们创建 5 个元素，保存在享元类内部，
         我们可以通过享元类为我们提供的 getDiv 来获取创建的元素。
         内部的数据和方法实现后，我们就要实现外部的数据和外部的方法，
         外部数据是我们要显示的所有新闻内容，每个内容都不一样，
         所以他们不能被共享。
         下一页绑定的数据是独立的，它只能绑定一次。然后我们要做两件事情
         1. 根据新闻的内容实例化页面
         2. 对下一页绑定一个点击事件，显示下一页的过程有个优化策略，
         就是如果当前页面显示的新闻数据不够5条，那么我们可以在新闻数据初始化处获取。
        这就要求我们新闻数据的总条数大于页面最多显示的条数 - 5 条。
        初始化页面
        */</span>
        <span class="hljs-keyword">var</span> articel = [
            <span class="hljs-string">'这是一条新闻1'</span>,
            <span class="hljs-string">'这是一条新闻2'</span>,
            <span class="hljs-string">'这是一条新闻3'</span>,
            <span class="hljs-string">'这是一条新闻4'</span>,
            <span class="hljs-string">'这是一条新闻5'</span>,
            <span class="hljs-string">'这是一条新闻6'</span>,
            <span class="hljs-string">'这是一条新闻7'</span>,
            <span class="hljs-string">'这是一条新闻8'</span>,
            <span class="hljs-string">'这是一条新闻9'</span>,
            <span class="hljs-string">'这是一条新闻10'</span>,
            <span class="hljs-string">'这是一条新闻11'</span>,
            <span class="hljs-string">'这是一条新闻12'</span>,
            <span class="hljs-string">'这是一条新闻13'</span>,
            <span class="hljs-string">'这是一条新闻14'</span>,
            <span class="hljs-string">'这是一条新闻15'</span>,
            <span class="hljs-string">'这是一条新闻16'</span>,
            <span class="hljs-string">'这是一条新闻17'</span>,
            <span class="hljs-string">'这是一条新闻18'</span>
        ];



        <span class="hljs-keyword">var</span> paper = <span class="hljs-number">0</span>,
            num = <span class="hljs-number">5</span>,
            len = articel.length;
        <span class="hljs-comment">// 添加 5 条新闻</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
            <span class="hljs-keyword">if</span>(articel[i]){
                <span class="hljs-comment">// 通过享元类获取创建的元素并写入新闻内容</span>
                Flyweight.getDiv().innerHTML = articel[i]
            }
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">page</span>(<span class="hljs-params">sub</span>)</span>{

        }

        <span class="hljs-comment">// 下一页绑定事件</span>
        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'next'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-comment">// 如果新闻内容不足5条不现实</span>
            <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">5</span>) {
                <span class="hljs-keyword">return</span>;
            };
            <span class="hljs-keyword">var</span> n, j = <span class="hljs-number">0</span>;
            n = ++paper * num % len;
            <span class="hljs-comment">// 插入5条新闻</span>
            <span class="hljs-keyword">for</span>(;j&lt;<span class="hljs-number">5</span>;j++){
                <span class="hljs-comment">// 如果存在第 n + j 条则插入</span>
                <span class="hljs-keyword">if</span>(articel[n+j]){
                    Flyweight.getDiv().innerHTML = articel[n+j];
                }
                <span class="hljs-comment">// 否则插入其实位置第  n + j -len</span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(articel[n + j - len]){
                    Flyweight.getDiv().innerHTML = articel[n + j -len];
                }<span class="hljs-keyword">else</span>{
                    Flyweight.getDiv().innerHTML = <span class="hljs-string">''</span>;
                }
            }
        }
</code></pre>
<ol start="12">
<li>PROXY—跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</li>
</ol>
<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<h1 id="行为模式">行为模式 <a class="markdownIt-Anchor" href="#行为模式">#</a></h1>
<ol start="13">
<li>CHAIN OF RESPONSIBLEITY—晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!</li>
</ol>
<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接</p>
<p>起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<ol start="14">
<li>COMMAND—俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。”，😦</li>
</ol>
<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
<ol start="15">
<li>INTERPRETER—俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。</li>
</ol>
<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
<ol start="16">
<li>ITERATOR—我爱上了Mary，不顾一切的向她求婚。</li>
</ol>
<p>Mary：“想要我跟你结婚，得答应我的条件”<br>
我：“什么条件我都答应，你说吧”<br>
Mary：“我看上了那个一克拉的钻石”<br>
我：“我买，我买，还有吗？”<br>
Mary：“我看上了湖边的那栋别墅”<br>
我：“我买，我买，还有吗？”<br>
Mary：“你的小弟弟必须要有50cm长”<br>
我脑袋嗡的一声，坐在椅子上，一咬牙：“我剪，我剪，还有吗？”<br>
……</p>
<p>迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
<ol start="17">
<li>MEDIATOR—四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</li>
</ol>
<p>调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<ol start="18">
<li>MEMENTO—同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</li>
</ol>
<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<ol start="19">
<li>OBSERVER—想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦</li>
</ol>
<p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<ol start="20">
<li>STATE—跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。</li>
</ol>
<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<ol start="21">
<li>STRATEGY—跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。</li>
</ol>
<p>策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
<ol start="22">
<li>TEMPLATE METHOD——看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；</li>
</ol>
<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<ol start="23">
<li>VISITOR—情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</li>
</ol>
<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>

      
    </div>
    <div  dir="ltr" class="level article-bar is-mobile">
      <div class="level-item has-text-centered">
        <a title="previous page" class="previouse-article-link" href="js中__proto__和prototype的区别和关系.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a>
      </div>
      <div class="level-item has-text-centered">
        <a title="font size" class="link-item link-item-size">
          <span class="icon icon-size" data-icon="size"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="table of content" class="link-item link-item-toc">
          <span class="icon icon-toc" data-icon="toc"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="top" href="#">
          <span class="icon icon-up" data-icon="up"></span>
          <span class="link-content">⤊ Top</span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="next page" class="next-article-link" href="JavaScript调试技巧.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a>
      </div>
    </div>
  </div>
  <div class="column is-2-widescreen is-hidden">
  </div>
</div>

<div class="columns foot">
  <div class="column is-3 is-offset-9 build-by">
    Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.4
  </div>
</div>

<div class="book-toc notification is-warning is-hidden">
  <h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close </a></span></h3>
  <ul class="chapter-area"><li class="chapter-item "><a href="前端面试题.html">面试复盘</a></li><li class="chapter-item "><a href="jQuery插件开发.html">jQuery插件开发</a></li><li class="chapter-item "><a href="ajax技术相关.html">ajax技术相关</a></li><li class="chapter-item "><a href="vue插件.html">vue插件</a></li><li class="chapter-item "><a href="在Vue.js中使用任意JavaScript第三方库.html">在Vue.js中使用任意JavaScript第三方库</a></li><li class="chapter-item "><a href="BFC.html">BFC</a></li><li class="chapter-item "><a href="reflow_repaint.html">页面回流和重绘</a></li><li class="chapter-item "><a href="setTimeout_setInterval.html">setTimeout 和 setInterval 的使用区别</a></li><li class="chapter-item "><a href="js中__proto__和prototype的区别和关系.html">js中__proto__和prototype的区别和关系(2017.12.6)</a></li><li class="chapter-item chapter-item-current"><a href="设计模式.html">设计模式白话篇</a></li><li class="chapter-item "><a href="JavaScript调试技巧.html">JavaScript调试技巧</a></li><li class="chapter-item "><a href="跳转到当前位置.html">跳转到当前位置</a></li><li class="chapter-item "><a href="return.html">return 的小问题</a></li><li class="chapter-item "><a href="./兼容小百科/flex在安卓4.3中的兼容方式.html">兼容小百科 - flex在安卓4.3中的兼容方式</a></li><ul class="chapter-level-2"></ul>
</div>

<div class="progress-indicator"></div>

<!-- SCRIPTS -->
<script>
  var LOPPO = {};
  LOPPO.current_path = '设计模式.md';
  LOPPO.relative_root_path = '';
  LOPPO.article_toc = "<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-factory\">工厂模式 FACTORY</a></li>\n<li><a href=\"#%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F-builder\">建造模式 BUILDER</a></li>\n<li><a href=\"#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-factory-method\">工厂方法模式 FACTORY METHOD</a></li>\n<li><a href=\"#%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%BC%8F-prototype\">原始模型模式 PROTOTYPE</a></li>\n<li><a href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-singleton\">单例模式 SINGLETON</a></li>\n<li><a href=\"#%E9%80%82%E9%85%8D%E5%99%A8-adapter\">适配器 ADAPTER</a></li>\n</ul>\n";
</script>
<script src="assets/js/app.js"></script>

</body>
</html>

