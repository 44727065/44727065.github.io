<!DOCTYPE html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta charset="utf-8">
<title>面试题回顾 - 老郭记事</title>
<meta name="description" content="">
<meta name="author" content="">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
<link rel="stylesheet" href="assets/css/bulma.min.css">
<link rel="stylesheet" href="assets/css/app.css">
<!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->
<link rel="shortcut icon" href="">
</head>
<body dir="ltr">

<nav class="columns navbar">
  <div class="column logo is-3 is-offset-1">
    <a class="is-brand" href="index.html">
      老郭记事
    </a>
  </div>
</nav>

<div class="columns content">
  <div class="column is-2-desktop is-3-widescreen is-hidden-touch">
  </div>
  <div class="column article-container is-11-tablet is-8-desktop is-6-widescreen">
    <div class="breadcrumb-area"><a href="index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="前端面试题.html" class="breadcrumb-item">面试复盘</a></div>
    <h1 class="article-title">面试题回顾</h1>
    <div class="article">
      <h2 id="实现-objectsetab-和objectgeta方法">实现 object.set('a','b') 和object.get('a')方法 <a class="markdownIt-Anchor" href="#实现-objectsetab-和objectgeta方法">#</a></h2>
<h3 id="实现方法一">实现方法一 <a class="markdownIt-Anchor" href="#实现方法一">#</a></h3>
<pre class="hljs"><code>  <span class="hljs-keyword">var</span> hashMap = {
        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key,value</span>) </span>{
            <span class="hljs-keyword">this</span>[key] = value;
        },
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[key];
        },
        <span class="hljs-attr">contains</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(key) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;
        },
        <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>[key];
        }
    };
</code></pre>
<h3 id="第二中方法，es6">第二中方法，ES6 <a class="markdownIt-Anchor" href="#第二中方法，es6">#</a></h3>
<pre class="hljs"><code><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
      m.set(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>);
<span class="hljs-built_in">console</span>.log(m.get(<span class="hljs-string">'a'</span>));
</code></pre>
<h3 id="第三种方法构造函数方法">第三种方法,构造函数方法 <a class="markdownIt-Anchor" href="#第三种方法构造函数方法">#</a></h3>
<pre class="hljs"><code>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">key,value</span>)</span>{
            <span class="hljs-keyword">this</span>.name = {};
            <span class="hljs-keyword">var</span> len = <span class="hljs-built_in">arguments</span>.length;
            <span class="hljs-keyword">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>)</span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[key];
            }
            <span class="hljs-keyword">this</span>.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key,value</span>)</span>{
                <span class="hljs-keyword">var</span> str = <span class="hljs-string">'{"'</span>+ key + <span class="hljs-string">'":"'</span> + value + <span class="hljs-string">'"}'</span>;
                _this.name = <span class="hljs-built_in">JSON</span>.parse(str);
            };
    }

    People(<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>)

    <span class="hljs-built_in">console</span>.log(People.name);
</code></pre>
<p>JSON.parse 可以做更多的事情 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener">MDN</a>;</p>
<h2 id="理解-settimeout-是-window-对象的方法">理解 setTimeout 是 window 对象的方法 <a class="markdownIt-Anchor" href="#理解-settimeout-是-window-对象的方法">#</a></h2>
<p>setTimeout的常见用法是让某个方法延迟执行。setTimeout方法是挂在window对象下的。《JavaScript高级程序设计》第二版中，写到：“超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined”。在这里，我们只讨论非严格模式。<br>
setTimeout接受两个参数，第一个是要执行的代码或函数，第二个是延迟的时间。</p>
<pre class="hljs"><code>  <span class="hljs-keyword">var</span> obj = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'aaaa'</span>,
        <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// console.log(this);</span>
            alert(<span class="hljs-keyword">this</span>.name);
        },
        <span class="hljs-attr">testGet</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// console.log(this);</span>
            setTimeout(<span class="hljs-keyword">this</span>.getName, <span class="hljs-number">0</span>); <span class="hljs-comment">// 这里的 js 指向就是 window 了，因此就是 undifined</span>
        }
    };
    obj.testGet();
</code></pre>
<p>再来看看下面的输出顺序</p>
<pre class="hljs"><code>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a'</span>);
    setTimeout(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b'</span>),<span class="hljs-number">0</span>); <span class="hljs-comment">// 会被延迟执行函数中调用</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'c'</span>);
</code></pre>
<h2 id="循环的问题">循环的问题 <a class="markdownIt-Anchor" href="#循环的问题">#</a></h2>
<pre class="hljs"><code>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"lst"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>22222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>33333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>44444<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>55555<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<pre class="hljs"><code>    <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#lst"</span>).querySelectorAll(<span class="hljs-string">'li'</span>);
    <span class="hljs-keyword">var</span> len = li.length;
    <span class="hljs-comment">// 第一种方案，通过闭包</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;len;i++){
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>{
            li[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
                <span class="hljs-built_in">console</span>.log(i);
            }
        })(i)
    }
    <span class="hljs-comment">// 第二种方案，将执行函数写到外面</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getConsoleLog</span>(<span class="hljs-params">i</span>)</span>{
        li[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-built_in">console</span>.log(i);
        }
    }

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i&lt;len ; i++){
        getConsoleLog(i);
    }

    <span class="hljs-comment">// 第三种方案，ES6</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt;len; i++){
        li[i].onclick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 因为每一次的 i 都是新的</span>
    }

</code></pre>
<h2 id="写一个mul函数，使用方法如下，使用方法如下-mul234-output24-mul434-output48">写一个mul函数，使用方法如下，使用方法如下 mul(2)(3)(4) output:24 mul(4)(3)(4) output:48 <a class="markdownIt-Anchor" href="#写一个mul函数，使用方法如下，使用方法如下-mul234-output24-mul434-output48">#</a></h2>
<pre class="hljs"><code><span class="hljs-comment">// ES 5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mul</span>(<span class="hljs-params">x</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">z</span>)</span>{
            <span class="hljs-keyword">return</span> x * y * z;
        }
    }
}
<span class="hljs-built_in">console</span>.log(mul(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>));
</code></pre>
<pre class="hljs"><code><span class="hljs-comment">// ES 6</span>
<span class="hljs-keyword">let</span> mul = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span><span class="hljs-function">(<span class="hljs-params">y</span>)=&gt;</span><span class="hljs-function">(<span class="hljs-params">z</span>) =&gt;</span> x*y*z;
<span class="hljs-built_in">console</span>.log(mul(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>));
</code></pre>
<ul>
<li>函数是一等公民</li>
<li>函数可以有属性，并且能连接到它的构造方法</li>
<li>函数可以像一个变量一样存在内存中</li>
<li>函数可以当做参数传给其他函数</li>
<li>函数可以返回其他函数</li>
</ul>
<h2 id="判断一个-object-是否是数组（array）">判断一个 object 是否是数组（array） <a class="markdownIt-Anchor" href="#判断一个-object-是否是数组（array）">#</a></h2>
<pre class="hljs"><code>    <span class="hljs-comment">// 判断一个对象是否是数组</span>
    <span class="hljs-comment">// Object.prototype.toString 来判断是否是数组</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">obj</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(obj))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">'[object Array]'</span>;
    }
    isArray({<span class="hljs-attr">a</span>:<span class="hljs-string">'b'</span>});
    isArray(<span class="hljs-string">'a'</span>);
    isArray([<span class="hljs-string">'1'</span>,<span class="hljs-number">2</span>]);
</code></pre>
<pre class="hljs"><code>    <span class="hljs-comment">// 使用原型链来完成判断</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">obj</span>)</span>{
        <span class="hljs-built_in">console</span>.log(obj.__proto__);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype);
        <span class="hljs-keyword">return</span> obj.__proto__ === <span class="hljs-built_in">Array</span>.prototype;
    }
    isArray({<span class="hljs-attr">a</span>:<span class="hljs-string">'b'</span>});
    isArray(<span class="hljs-string">'a'</span>);
    isArray([<span class="hljs-string">'1'</span>,<span class="hljs-number">2</span>]);
</code></pre>
<h2 id="操作-object-属性">操作 object 属性 <a class="markdownIt-Anchor" href="#操作-object-属性">#</a></h2>
<pre class="hljs"><code>    <span class="hljs-comment">// delete 是针对 object 属性操作的，x 并不是对象的属性，delete 操作符不起作用</span>
    <span class="hljs-keyword">var</span> output = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>{
        <span class="hljs-keyword">delete</span> x;
        <span class="hljs-keyword">return</span> x;
    })(<span class="hljs-number">0</span>)
    <span class="hljs-built_in">console</span>.log(output);

    <span class="hljs-comment">// delete 不能删除 prototype 继承的属性</span>
    <span class="hljs-keyword">var</span> Employee = {
        <span class="hljs-attr">company</span> : <span class="hljs-string">'xyz'</span>
    }

    <span class="hljs-keyword">var</span> emp1 = <span class="hljs-built_in">Object</span>.create(Employee); <span class="hljs-comment">// 通过 prototype 继承 company，delete 操作不了 prototype 的属性</span>
    <span class="hljs-keyword">delete</span> emp1.company;
    <span class="hljs-built_in">console</span>.log(emp1.company);

    <span class="hljs-comment">// 用 delete 操作一个数组中的元素，这个位置会变成占位符</span>
    <span class="hljs-keyword">var</span> trees = [<span class="hljs-string">'redwood'</span>,<span class="hljs-string">'bay'</span>,<span class="hljs-string">'oak'</span>,<span class="hljs-string">'maple'</span>];

    <span class="hljs-keyword">delete</span> trees[<span class="hljs-number">1</span>];

    <span class="hljs-built_in">console</span>.log(trees[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 返回 undefined ,数组长度不变</span>
</code></pre>
<h2 id="instanceof-操作符">instanceof 操作符 <a class="markdownIt-Anchor" href="#instanceof-操作符">#</a></h2>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> foo;
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> foo() <span class="hljs-keyword">instanceof</span> foo); <span class="hljs-comment">//构造函数不需要 return，如果return的话也是 return this</span>
</code></pre>
<h2 id="怎么计算关联数组长度">怎么计算关联数组长度 <a class="markdownIt-Anchor" href="#怎么计算关联数组长度">#</a></h2>
<pre class="hljs"><code><span class="hljs-keyword">var</span> counterArray = {
    <span class="hljs-attr">A</span> : <span class="hljs-number">3</span>,
    <span class="hljs-attr">B</span> : <span class="hljs-number">4</span>
};
counterArray[<span class="hljs-string">"C"</span>] = <span class="hljs-number">1</span>;
<span class="hljs-built_in">Object</span>.keys(counterArray).length <span class="hljs-comment">// Output 3</span>
</code></pre>
<h2 id="实现-var-arr--123456转成-123456">实现 var arr = [1,2,3,[4,5,6]...]转成 [1,2,3,4,5,6,...] <a class="markdownIt-Anchor" href="#实现-var-arr--123456转成-123456">#</a></h2>
<pre class="hljs"><code><span class="hljs-keyword">var</span> _temArr = [];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arryOneleve</span>(<span class="hljs-params">arr</span>)</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> arr){
        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">typeof</span> arr[item]) != <span class="hljs-string">'object'</span>){
            _temArr.push(arr[item]);
        }<span class="hljs-keyword">else</span>{
            arryOneleve(arr[item]);
        }
    }
    <span class="hljs-keyword">return</span> _temArr;
}

<span class="hljs-built_in">console</span>.log(arryOneleve([[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]));

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> _tempArr = [];
<span class="hljs-keyword">let</span> arryCovert = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> arr){
        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">typeof</span> arr[item]) != <span class="hljs-string">'object'</span>){
            _tempArr.push(arr[item]);
        }<span class="hljs-keyword">else</span>{
            arryCovert(arr[item]);
        }
    }
    <span class="hljs-comment">//return _tempArr;</span>
}

arryCovert([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]);
<span class="hljs-built_in">console</span>.log(_tempArr);
</code></pre>
<p>看似烟花缭乱，其实有更简单的办法</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]].toString());
</code></pre>
<h2 id="stringnumber-类型转化">String/Number 类型转化 <a class="markdownIt-Anchor" href="#stringnumber-类型转化">#</a></h2>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> (<span class="hljs-string">'11'</span> + <span class="hljs-number">2</span> - <span class="hljs-string">'1'</span>)); <span class="hljs-comment">// 有减号出现就是 number 类型了</span>

</code></pre>
<h2 id="数组操作">数组操作 <a class="markdownIt-Anchor" href="#数组操作">#</a></h2>
<pre class="hljs"><code><span class="hljs-comment">// 数组合并</span>
<span class="hljs-keyword">var</span> stringArray = [<span class="hljs-string">'This'</span>, <span class="hljs-string">'is'</span>, <span class="hljs-string">'Baidu'</span>, <span class="hljs-string">'Campus'</span>];
alert(stringArray.join(<span class="hljs-string">' '</span>));
<span class="hljs-comment">// foo="get-element-by-id" 转换成驼峰</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertToCamel</span>(<span class="hljs-params">str</span>)</span>{
    <span class="hljs-keyword">var</span> arr = str.split(<span class="hljs-string">'-'</span>);
    <span class="hljs-built_in">console</span>.log(arr);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length ;i++){
        <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>){
            arr[i] = arr[i].charAt(<span class="hljs-number">0</span>).toUpperCase() + arr[i].substr(<span class="hljs-number">1</span>,arr[i].length<span class="hljs-number">-1</span>);
        }
    }
    <span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">''</span>);
}
<span class="hljs-built_in">console</span>.log(convertToCamel(<span class="hljs-string">"get-element-by-id"</span>));
</code></pre>
<h2 id="sort-排序的坑">sort() 排序的坑 <a class="markdownIt-Anchor" href="#sort-排序的坑">#</a></h2>
<pre class="hljs"><code><span class="hljs-keyword">let</span> numberArr = [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2000</span>];
numberArr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>{ <span class="hljs-comment">// sort 默认是按照字符串排序的，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</span>
    <span class="hljs-keyword">return</span> a - b;
});
<span class="hljs-built_in">console</span>.log(numberArr);
</code></pre>
<h2 id="操作键值对">操作键值对 <a class="markdownIt-Anchor" href="#操作键值对">#</a></h2>
<p>有这样一个URLhttp://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:'1', b:'2', c:'', d:'xxx', e:undefined}</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatUrl</span>(<span class="hljs-params">str</span>)</span>{
    <span class="hljs-keyword">var</span> _result = {};
    <span class="hljs-keyword">var</span> search = str.split(<span class="hljs-string">'?'</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">'&amp;'</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> search){
        <span class="hljs-keyword">var</span> kv = search[item].split(<span class="hljs-string">'='</span>);
        _result[kv[<span class="hljs-number">0</span>]] = kv[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前面是 key ，后面是 value</span>
    }
    <span class="hljs-built_in">console</span>.log(_result);
    <span class="hljs-keyword">return</span> _result;
}

formatUrl(<span class="hljs-string">'http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e'</span>);
</code></pre>
<h2 id="正则表达式构造函数var-regnew-regexpxxx与正则表达字面量var-reg有什么不同？">正则表达式构造函数var reg=new RegExp(&quot;xxx&quot;)与正则表达字面量var reg=//有什么不同？ <a class="markdownIt-Anchor" href="#正则表达式构造函数var-regnew-regexpxxx与正则表达字面量var-reg有什么不同？">#</a></h2>
<p>答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即&quot;表示&quot;），并且还需要双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。<br>
邮箱的正则匹配/手机的正则表达式匹配</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> regMail = <span class="hljs-regexp">/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/</span>;
    <span class="hljs-keyword">var</span> regMobile = <span class="hljs-regexp">/(13\d|14[579]|15\d|17[01235678]|18\d)\d{8}/i</span>;

    <span class="hljs-built_in">console</span>.log(regMobile.test(<span class="hljs-string">'18610556294'</span>))
    <span class="hljs-built_in">console</span>.log(regMobile.exec(<span class="hljs-string">'18610556294'</span>))
</code></pre>
<ul>
<li>
<p>正则表达式中的特殊字符</p>
</li>
<li>
<p>字符 含意</p>
</li>
<li>
<p>\ 做为转意，即通常在&quot;&quot;后面的字符不按原来意义解释，如/b/匹配字符&quot;b&quot;，当b前面加了反斜杆后/\b/，转意为匹配一个单词的边界。</p>
</li>
<li>
<p>-或-</p>
</li>
<li>
<p>对正则表达式功能字符的还原，如&quot;<em>&quot;匹配它前面元字符0次或多次，/a</em>/将匹配a,aa,aaa，加了&quot;&quot;后，/a*/将只匹配&quot;a*&quot;。</p>
</li>
<li>
<p>^ 匹配一个输入或一行的开头，/^a/匹配&quot;an A&quot;，而不匹配&quot;An a&quot;</p>
</li>
<li>
<p>$ 匹配一个输入或一行的结尾，/a$/匹配&quot;An a&quot;，而不匹配&quot;an A&quot;</p>
</li>
<li>
<ul>
<li>匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa</li>
</ul>
</li>
<li>
<ul>
<li>匹配前面元字符1次或多次，/ba*/将匹配ba,baa,baaa</li>
</ul>
</li>
<li>
<p>? 匹配前面元字符0次或1次，/ba*/将匹配b,ba</p>
</li>
<li>
<p>(x) 匹配x保存x在名为$1...$9的变量中</p>
</li>
<li>
<p>x|y 匹配x或y</p>
</li>
<li>
<p>{n} 精确匹配n次</p>
</li>
<li>
<p>{n,} 匹配n次以上</p>
</li>
<li>
<p>{n,m} 匹配n-m次</p>
</li>
<li>
<p>[xyz] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符)</p>
</li>
<li>
<p>[^xyz] 不匹配这个集合中的任何一个字符</p>
</li>
<li>
<p>[\b] 匹配一个退格符</p>
</li>
<li>
<p>\b 匹配一个单词的边界</p>
</li>
<li>
<p>\B 匹配一个单词的非边界</p>
</li>
<li>
<p>\cX 这儿，X是一个控制符，/\cM/匹配Ctrl-M</p>
</li>
<li>
<p>\d 匹配一个字数字符，/\d/ = /[0-9]/</p>
</li>
<li>
<p>\D 匹配一个非字数字符，/\D/ = /[^0-9]/</p>
</li>
<li>
<p>\n 匹配一个换行符</p>
</li>
<li>
<p>\r 匹配一个回车符</p>
</li>
<li>
<p>\s 匹配一个空白字符，包括\n,\r,\f,\t,\v等</p>
</li>
<li>
<p>\S 匹配一个非空白字符，等于/[^\n\f\r\t\v]/</p>
</li>
<li>
<p>\t 匹配一个制表符</p>
</li>
<li>
<p>\v 匹配一个重直制表符</p>
</li>
<li>
<p>\w 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\w]匹配&quot;$5.98&quot;中的5，等于[a-zA-Z0-9]</p>
</li>
<li>
<p>\W 匹配一个不可以组成单词的字符，如[\W]匹配&quot;5.98"中的，等于[^a-zA-Z0-9]。<br>
<a href="http://www.jb51.net/article/43190.htm" target="_blank" rel="noopener">http://www.jb51.net/article/43190.htm</a></p>
</li>
</ul>
<h2 id="写一个function，清除字符串前后的空格。（兼容所有浏览器）">写一个function，清除字符串前后的空格。（兼容所有浏览器） <a class="markdownIt-Anchor" href="#写一个function，清除字符串前后的空格。（兼容所有浏览器）">#</a></h2>
<p>使用特性检测。</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">String</span>.prototype.trim) {
    <span class="hljs-built_in">String</span>.prototype.trim = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.replace(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">""</span>).replace(<span class="hljs-regexp">/\s+$/</span>,<span class="hljs-string">""</span>);
    }
}
<span class="hljs-comment">// test the function</span>
<span class="hljs-keyword">var</span> str = <span class="hljs-string">" \t\n test string "</span>.trim();
alert(str == <span class="hljs-string">"test string"</span>); <span class="hljs-comment">// alerts "true"</span>
</code></pre>
<h2 id="javascript中callee和caller的作用？">Javascript中callee和caller的作用？ <a class="markdownIt-Anchor" href="#javascript中callee和caller的作用？">#</a></h2>
<p>caller是返回一个对函数的引用，该函数调用了当前函数；<br>
callee是返回正在被执行的function函数，也就是所指定的function对象的正文。<br>
那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成）</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> result=[];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">n</span>)</span>{  <span class="hljs-comment">//典型的斐波那契数列</span>
   <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
   }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>){
           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
   }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">if</span>(result[n]){
                <span class="hljs-keyword">return</span> result[n];
        }<span class="hljs-keyword">else</span>{
                <span class="hljs-comment">//argument.callee()表示fn()</span>
                result[n]=<span class="hljs-built_in">arguments</span>.callee(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">arguments</span>.callee(n<span class="hljs-number">-2</span>);
                <span class="hljs-keyword">return</span> result[n];
        }
   }
}
</code></pre>
<h2 id="实现一个函数clone，可以对javascript中的5种主要的数据类型（包括number、string、object、array、boolean）进行值复制">实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制 <a class="markdownIt-Anchor" href="#实现一个函数clone，可以对javascript中的5种主要的数据类型（包括number、string、object、array、boolean）进行值复制">#</a></h2>
<ul>
<li>考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚</li>
<li>考察点2：是否知道如何判断一个变量是什么类型的</li>
<li>考察点3：递归算法的设计</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// 方法一：</span>
<span class="hljs-built_in">Object</span>.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.constructor);
    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">this</span>.constructor === <span class="hljs-built_in">Array</span> ? [] : {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) {
        o[e] = <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>[e] === <span class="hljs-string">"object"</span> ? <span class="hljs-keyword">this</span>[e].clone() : <span class="hljs-keyword">this</span>[e];
    }
    <span class="hljs-keyword">return</span> o;
}
<span class="hljs-keyword">var</span> aa = {<span class="hljs-number">1</span>:<span class="hljs-number">2</span>}
<span class="hljs-keyword">var</span> bb = aa.clone()
aa[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;
<span class="hljs-built_in">console</span>.log(aa);
<span class="hljs-built_in">console</span>.log(bb);
<span class="hljs-comment">//方法二：</span>
<span class="hljs-comment">/**
 * 克隆一个对象
 * @param Obj
 * @returns
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">Obj</span>) </span>{
    <span class="hljs-keyword">var</span> buf;
    <span class="hljs-keyword">if</span> (Obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
        buf = []; <span class="hljs-comment">//创建一个空的数组</span>
        <span class="hljs-keyword">var</span> i = Obj.length;
        <span class="hljs-keyword">while</span> (i--) {
            buf[i] = clone(Obj[i]);
        }
        <span class="hljs-keyword">return</span> buf;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) {
        buf = {}; <span class="hljs-comment">//创建一个空对象</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> Obj) { <span class="hljs-comment">//为这个对象添加新的属性</span>
            buf[k] = clone(Obj[k]);
        }
        <span class="hljs-keyword">return</span> buf;
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">//普通变量直接赋值</span>
        <span class="hljs-keyword">return</span> Obj;
    }
}
<span class="hljs-keyword">var</span> cc = clone(<span class="hljs-number">9</span>)
<span class="hljs-built_in">console</span>.log(cc);
</code></pre>
<h2 id="倒计时">倒计时 <a class="markdownIt-Anchor" href="#倒计时">#</a></h2>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> t = <span class="hljs-number">60</span>;
    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div'</span>);
    div.innerHTML = t.toString();

    <span class="hljs-keyword">var</span> interval = setInterval(del,<span class="hljs-number">1000</span>); <span class="hljs-comment">// 函数内部定义计时器</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">del</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">if</span>(t &lt;= <span class="hljs-number">0</span>){
            clearInterval(interval); <span class="hljs-comment">// 什么时候取消计时器</span>
        }
        <span class="hljs-keyword">else</span>{
            t--;;
            div.innerHTML = t.toString();
        }
    }
}
test()
</code></pre>
<h2 id="js-创建表格">js 创建表格 <a class="markdownIt-Anchor" href="#js-创建表格">#</a></h2>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creatTable</span>(<span class="hljs-params">rowNum,colNum</span>)</span>{
    <span class="hljs-keyword">var</span> row = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;rowNum ; i++){
        row += <span class="hljs-string">'&lt;tr&gt;'</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; colNum; j++){
            row += <span class="hljs-string">'&lt;td&gt;'</span> + <span class="hljs-string">'中间位置'</span> + <span class="hljs-string">'&lt;/td&gt;'</span>;
        }
        row += <span class="hljs-string">'&lt;/tr&gt;'</span>;
    }
    <span class="hljs-keyword">var</span> table = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'table'</span>);
    table.innerHTML = row; <span class="hljs-comment">// 理解 innerHTML</span>
    <span class="hljs-keyword">var</span> wrap = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'wrap'</span>);
    wrap.appendChild(table)
}
creatTable(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)
</code></pre>
<h2 id="js如何实现面向对象和继承机制">JS如何实现面向对象和继承机制 <a class="markdownIt-Anchor" href="#js如何实现面向对象和继承机制">#</a></h2>
<p>构造器继承，原型继承，混合继承，寄生继承</p>
<h3 id="构造器继承">构造器继承 <a class="markdownIt-Anchor" href="#构造器继承">#</a></h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">a</span>)</span>{
    <span class="hljs-keyword">this</span>.a = a;
    <span class="hljs-keyword">this</span>.func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">a</span>)</span>{
    Super.call(<span class="hljs-keyword">this</span>,a);
}
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Sub();
obj{
    <span class="hljs-attr">a</span>:<span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">func</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}
}
</code></pre>
<h3 id="原型继承">原型继承 <a class="markdownIt-Anchor" href="#原型继承">#</a></h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">a</span>)</span>{
    <span class="hljs-keyword">this</span>.a = a;
    <span class="hljs-keyword">this</span>.func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params"></span>)</span>{
}
Sub.prototype = <span class="hljs-keyword">new</span> Super();
Sub.prototype.constructor = Sub;
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Sub();

obj{ <span class="hljs-attr">__proto__</span>:{ <span class="hljs-attr">a</span>:<span class="hljs-literal">undefined</span>, <span class="hljs-attr">func</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},
        <span class="hljs-attr">constructor</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params"></span>)</span>{} } }
</code></pre>
<h3 id="混合继承">混合继承 <a class="markdownIt-Anchor" href="#混合继承">#</a></h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">a</span>)</span>{
    <span class="hljs-keyword">this</span>.a = a;
    <span class="hljs-keyword">this</span>.func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">a</span>)</span>{
    Super.call(<span class="hljs-keyword">this</span>,a);
}
Sub.prototype = <span class="hljs-keyword">new</span> Super();
Sub.prototype.constructor = Sub;
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Sub();
obj{ <span class="hljs-attr">a</span>:<span class="hljs-literal">undefined</span>, <span class="hljs-attr">func</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},
    <span class="hljs-attr">__proto__</span>:{ <span class="hljs-attr">a</span>:<span class="hljs-literal">undefined</span>, <span class="hljs-attr">func</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},
        <span class="hljs-attr">constructor</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params"></span>)</span>{} } }
</code></pre>
<h3 id="寄生继承">寄生继承 <a class="markdownIt-Anchor" href="#寄生继承">#</a></h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">a</span>)</span>{
    <span class="hljs-keyword">this</span>.a = a;
    <span class="hljs-keyword">this</span>.func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
}
Super.prototype.talk = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'talk'</span>);}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">a</span>)</span>{
    Super.call(<span class="hljs-keyword">this</span>,a);
}
Sub.prototype = <span class="hljs-built_in">Object</span>.create(Super.prototype);
Sub.prototype.constructor = Sub;
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Sub();

obj{ <span class="hljs-attr">a</span>:<span class="hljs-literal">undefined</span>, <span class="hljs-attr">func</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},
    <span class="hljs-attr">__proto__</span>:{ <span class="hljs-attr">constructor</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params"></span>)</span>{},
        <span class="hljs-attr">__proto__</span>:{ <span class="hljs-attr">talk</span> :<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'talk'</span>);}
            <span class="hljs-keyword">constructor</span>:function Super(){}
        }

    }
}
</code></pre>
<h2 id="undefined"> <a class="markdownIt-Anchor" href="#undefined">#</a></h2>
<pre class="hljs"><code>&lt;script type=<span class="hljs-string">"text/javascript"</span> language=<span class="hljs-string">"Javascript"</span> src=<span class="hljs-string">"http://ajax.aspnetcdn.com/ajax/jquery/jquery-1.4.1.min.js "</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
&lt;script type=<span class="hljs-string">'text/javascript'</span>&gt;<span class="hljs-comment">//&lt;![CDATA[</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> jQuery == <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-built_in">document</span>.write(<span class="hljs-built_in">unescape</span>(<span class="hljs-string">"%3Cscript src='/Script/jquery-1.4.1.min.js' type='text/javascript' %3E%3C/script%3E"</span>));
}<span class="hljs-comment">//]]&gt;</span>
&lt;<span class="hljs-regexp">/script&gt;
</span></code></pre>
<h2 id="foo--foobar-，这行代码是什么意思？为什么要这样写？">foo = foo||bar ，这行代码是什么意思？为什么要这样写？ <a class="markdownIt-Anchor" href="#foo--foobar-，这行代码是什么意思？为什么要这样写？">#</a></h2>
<p>答案：if(!foo) foo = bar; //如果foo存在，值不变，否则把bar的值赋给foo。<br>
短路表达式：作为&quot;&amp;&amp;&quot;和&quot;||&quot;操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。</p>
<h2 id="caller-和-callee-的区别">caller 和 callee 的区别 <a class="markdownIt-Anchor" href="#caller-和-callee-的区别">#</a></h2>
<p>caller返回一个函数的引用，这个函数调用了当前的函数;callee放回正在执行的函数本身的引用，它是arguments的一个属性<br>
<strong> caller </strong><br>
caller返回一个函数的引用，这个函数调用了当前的函数。</p>
<ol>
<li>这个属性只有当函数在执行时才有用</li>
<li>如果在javascript程序中，函数是由顶层调用的，则返回null<br>
functionName.caller: functionName是当前正在执行的函数。</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(a.caller);
}
<span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    a();
}
b();
a();
</code></pre>
<p>上面的代码中，b调用了a，那么a.caller返回的是b的引用.<br>
如果直接调用a(即a在任何函数中被调用，也就是顶层调用),返回null:<br>
<strong> callee </strong><br>
callee放回正在执行的函数本身的引用，它是arguments的一个属性</p>
<ol>
<li>这个属性只有在函数执行时才有效</li>
<li>它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length</li>
<li>它可以用来递归匿名函数。</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-built_in">arguments</span>.callee);
}
<span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    a();
}
b();
</code></pre>
<p>a在b中被调用，但是它返回了a本身的引用.</p>
<h2 id="一次完整的http事务是怎样的一个过程">一次完整的HTTP事务是怎样的一个过程 <a class="markdownIt-Anchor" href="#一次完整的http事务是怎样的一个过程">#</a></h2>
<ol>
<li>域名解析</li>
<li>发起TCP的3次握手</li>
<li>建立TCP连接后发起http请求</li>
<li>服务器端响应http请求，浏览器得到html代码</li>
<li>浏览器解析html代码，并请求html代码中的资源</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ol>
<h1 id="html-css-方面">HTML CSS 方面 <a class="markdownIt-Anchor" href="#html-css-方面">#</a></h1>
<h2 id="在cssjs代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？">在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？ <a class="markdownIt-Anchor" href="#在cssjs代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？">#</a></h2>
<p>答案：dns缓存，cdn缓存，浏览器缓存，服务器缓存。</p>
<h2 id="一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。">一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 <a class="markdownIt-Anchor" href="#一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。">#</a></h2>
<ul>
<li>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li>
<li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li>
<li>如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。</li>
<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>
<li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li>
</ul>
<h2 id="请用css写一个简单的幻灯片效果页面">请用Css写一个简单的幻灯片效果页面 <a class="markdownIt-Anchor" href="#请用css写一个简单的幻灯片效果页面">#</a></h2>
<pre class="hljs"><code><span class="hljs-comment">/**HTML**/</span>
<span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.ani</span>

<span class="hljs-comment">/**css**/</span>
<span class="hljs-selector-class">.ani</span>{
    <span class="hljs-attribute">width</span>:<span class="hljs-number">480px</span>;
    <span class="hljs-attribute">height</span>:<span class="hljs-number">320px</span>;
    <span class="hljs-attribute">margin</span>:<span class="hljs-number">50px</span> auto;
    <span class="hljs-attribute">overflow</span>: hidden;
    <span class="hljs-attribute">box-shadow</span>:<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(0,0,0,1);
    <span class="hljs-attribute">background-size</span>: cover;
    <span class="hljs-attribute">background-position</span>: center;
    <span class="hljs-attribute">-webkit-animation-name</span>: <span class="hljs-string">"loops"</span>;
    <span class="hljs-attribute">-webkit-animation-duration</span>: <span class="hljs-number">20s</span>;
    <span class="hljs-attribute">-webkit-animation-iteration-count</span>: infinite;
}
@-<span class="hljs-keyword">webkit</span>-<span class="hljs-keyword">keyframes</span> <span class="hljs-string">"loops"</span> {
    0% {
        <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat;
    }
    25% {
        <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat;
    }
    50% {
        <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat;
    }
    75% {
        <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat;
    }
    100% {
        <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat;
    }
}
</code></pre>
<h2 id="外边距重叠就是margin-collapse">外边距重叠就是margin-collapse <a class="markdownIt-Anchor" href="#外边距重叠就是margin-collapse">#</a></h2>
<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和。</li>
</ul>
<h2 id="如何垂直居中一个浮动元素？">如何垂直居中一个浮动元素？ <a class="markdownIt-Anchor" href="#如何垂直居中一个浮动元素？">#</a></h2>
<pre class="hljs"><code>// 方法一：已知元素的高宽

<span class="hljs-selector-id">#div1</span>{
    <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#6699FF</span>;
    <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;

    <span class="hljs-attribute">position</span>: absolute;        //父元素需要相对定位
    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">margin-top</span>:-<span class="hljs-number">100px</span> ;   //二分之一的height，width
    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;
    }

//方法二:

  <span class="hljs-selector-id">#div1</span>{
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#6699FF</span>;

    <span class="hljs-attribute">margin</span>:auto;
    <span class="hljs-attribute">position</span>: absolute;        //父元素需要相对定位
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
    }
</code></pre>
<h2 id="如何垂直居中一个img">如何垂直居中一个<img> <a class="markdownIt-Anchor" href="#如何垂直居中一个img">#</a></h2>
<pre class="hljs"><code>//&lt;<span class="hljs-selector-tag">img</span>&gt;的容器设置如下
<span class="hljs-selector-id">#container</span>
{
    <span class="hljs-attribute">display</span>:table-cell;
    <span class="hljs-attribute">text-align</span>:center;
    <span class="hljs-attribute">vertical-align</span>:middle;
}
</code></pre>
<h2 id="vue-面试题">VUE 面试题 <a class="markdownIt-Anchor" href="#vue-面试题">#</a></h2>
<h3 id="请谈谈vue中的mvvm模式">请谈谈Vue中的MVVM模式 <a class="markdownIt-Anchor" href="#请谈谈vue中的mvvm模式">#</a></h3>
<p>MVVM全称是Model-View-ViewModel<br>
Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。<br>
DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</p>
<h3 id="v-show和v-if指令的共同点和不同点">v-show和v-if指令的共同点和不同点? <a class="markdownIt-Anchor" href="#v-show和v-if指令的共同点和不同点">#</a></h3>
<ul>
<li>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏</li>
<li>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li>
</ul>
<h3 id="如何让css只在当前组件中起作用">如何让CSS只在当前组件中起作用? <a class="markdownIt-Anchor" href="#如何让css只在当前组件中起作用">#</a></h3>
<pre class="hljs"><code><span class="hljs-comment">// 将当前组件的 &lt;style&gt;  修改为  &lt;style scoped&gt;</span>
</code></pre>
<h3 id="keep-alive的作用是什么">keep-alive的作用是什么? <a class="markdownIt-Anchor" href="#keep-alive的作用是什么">#</a></h3>
<p>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。<br>
比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用keep-alive进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。</p>
<h3 id="vue中引入组件的步骤">Vue中引入组件的步骤? <a class="markdownIt-Anchor" href="#vue中引入组件的步骤">#</a></h3>
<ol>
<li>采用ES6的import ... from ...语法或CommonJS的require()方法引入组件</li>
<li>对组件进行注册,代码如下</li>
</ol>
<pre class="hljs"><code><span class="hljs-comment">// 注册</span>
Vue.component(<span class="hljs-string">'my-component'</span>, {
 <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span>
})
</code></pre>
<ol start="3">
<li>使用组件 my-component</li>
</ol>
<h3 id="在vue中使用插件的步骤">在Vue中使用插件的步骤 <a class="markdownIt-Anchor" href="#在vue中使用插件的步骤">#</a></h3>
<ol>
<li>采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件</li>
<li>使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })</li>
</ol>
<h3 id="请列举出3个vue中常用的生命周期钩子函数">请列举出3个Vue中常用的生命周期钩子函数? <a class="markdownIt-Anchor" href="#请列举出3个vue中常用的生命周期钩子函数">#</a></h3>
<ol>
<li>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见</li>
<li>mounted: el被新创建的 vm.el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.el 也在文档内。</li>
<li>activated::keep-alive组件激活时调用</li>
</ol>
<h3 id="请简述下vuex的原理和使用方法">请简述下Vuex的原理和使用方法 <a class="markdownIt-Anchor" href="#请简述下vuex的原理和使用方法">#</a></h3>
<p><img src="./images/vue_flow.png" alt=""><br>
一个应用可以看作是由上面三部分组成: <strong> View, Actions,State, </strong> 数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动.但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的.<br>
Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心.<br>
<img src="./images/vuex_flow.png" alt=""><br>
上图可以很好的说明Vuex的组成,一个实例化的Vuex.Store由state, mutations和actions三个属性组成:</p>
<ul>
<li>state中保存着共有数据</li>
<li>改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的</li>
<li>如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改.</li>
</ul>

      
    </div>
    <div  dir="ltr" class="level article-bar is-mobile">
      <div class="level-item has-text-centered">
        <a title="previous page" class="previouse-article-link" href="index.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a>
      </div>
      <div class="level-item has-text-centered">
        <a title="font size" class="link-item link-item-size">
          <span class="icon icon-size" data-icon="size"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="table of content" class="link-item link-item-toc">
          <span class="icon icon-toc" data-icon="toc"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="top" href="#">
          <span class="icon icon-up" data-icon="up"></span>
          <span class="link-content">⤊ Top</span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="next page" class="next-article-link" href="jQuery插件开发.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a>
      </div>
    </div>
  </div>
  <div class="column is-2-widescreen is-hidden">
  </div>
</div>

<div class="columns foot">
  <div class="column is-3 is-offset-9 build-by">
    Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.4
  </div>
</div>

<div class="book-toc notification is-warning is-hidden">
  <h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close </a></span></h3>
  <ul class="chapter-area"><li class="chapter-item chapter-item-current"><a href="前端面试题.html">面试复盘</a></li><li class="chapter-item "><a href="jQuery插件开发.html">jQuery插件开发</a></li><li class="chapter-item "><a href="ajax技术相关.html">ajax技术相关</a></li><li class="chapter-item "><a href="vue插件.html">vue插件</a></li></ul>
</div>

<div class="progress-indicator"></div>

<!-- SCRIPTS -->
<script>
  var LOPPO = {};
  LOPPO.current_path = '前端面试题.md';
  LOPPO.relative_root_path = '';
  LOPPO.article_toc = "<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%AE%9E%E7%8E%B0-objectsetab-%E5%92%8Cobjectgeta%E6%96%B9%E6%B3%95\">实现 object.set('a','b') 和object.get('a')方法</a>\n<ul>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%80\">实现方法一</a></li>\n<li><a href=\"#%E7%AC%AC%E4%BA%8C%E4%B8%AD%E6%96%B9%E6%B3%95%EF%BC%8Ces6\">第二中方法，ES6</a></li>\n<li><a href=\"#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95\">第三种方法,构造函数方法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%90%86%E8%A7%A3-settimeout-%E6%98%AF-window-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95\">理解 setTimeout 是 window 对象的方法</a></li>\n<li><a href=\"#%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98\">循环的问题</a></li>\n<li><a href=\"#%E5%86%99%E4%B8%80%E4%B8%AAmul%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%A6%82%E4%B8%8B-mul234-output24-mul434-output48\">写一个mul函数，使用方法如下，使用方法如下 mul(2)(3)(4) output:24 mul(4)(3)(4) output:48</a></li>\n<li><a href=\"#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA-object-%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%88array%EF%BC%89\">判断一个 object 是否是数组（array）</a></li>\n<li><a href=\"#%E6%93%8D%E4%BD%9C-object-%E5%B1%9E%E6%80%A7\">操作 object 属性</a></li>\n<li><a href=\"#instanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6\">instanceof 操作符</a></li>\n<li><a href=\"#%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6\">怎么计算关联数组长度</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0-var-arr--123456%E8%BD%AC%E6%88%90-123456\">实现 var arr = [1,2,3,[4,5,6]...]转成 [1,2,3,4,5,6,...]</a></li>\n<li><a href=\"#stringnumber-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96\">String/Number 类型转化</a></li>\n<li><a href=\"#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C\">数组操作</a></li>\n<li><a href=\"#sort-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%91\">sort() 排序的坑</a></li>\n<li><a href=\"#%E6%93%8D%E4%BD%9C%E9%94%AE%E5%80%BC%E5%AF%B9\">操作键值对</a></li>\n<li><a href=\"#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0var-regnew-regexpxxx%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%AD%97%E9%9D%A2%E9%87%8Fvar-reg%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F\">正则表达式构造函数var reg=new RegExp(&quot;xxx&quot;)与正则表达字面量var reg=//有什么不同？</a></li>\n<li><a href=\"#%E5%86%99%E4%B8%80%E4%B8%AAfunction%EF%BC%8C%E6%B8%85%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E5%90%8E%E7%9A%84%E7%A9%BA%E6%A0%BC%E3%80%82%EF%BC%88%E5%85%BC%E5%AE%B9%E6%89%80%E6%9C%89%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%89\">写一个function，清除字符串前后的空格。（兼容所有浏览器）</a></li>\n<li><a href=\"#javascript%E4%B8%ADcallee%E5%92%8Ccaller%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F\">Javascript中callee和caller的作用？</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0clone%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AF%B9javascript%E4%B8%AD%E7%9A%845%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%8C%85%E6%8B%ACnumber%E3%80%81string%E3%80%81object%E3%80%81array%E3%80%81boolean%EF%BC%89%E8%BF%9B%E8%A1%8C%E5%80%BC%E5%A4%8D%E5%88%B6\">实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</a></li>\n<li><a href=\"#%E5%80%92%E8%AE%A1%E6%97%B6\">倒计时</a></li>\n<li><a href=\"#js-%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC\">js 创建表格</a></li>\n<li><a href=\"#js%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6\">JS如何实现面向对象和继承机制</a>\n<ul>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%99%A8%E7%BB%A7%E6%89%BF\">构造器继承</a></li>\n<li><a href=\"#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF\">原型继承</a></li>\n<li><a href=\"#%E6%B7%B7%E5%90%88%E7%BB%A7%E6%89%BF\">混合继承</a></li>\n<li><a href=\"#%E5%AF%84%E7%94%9F%E7%BB%A7%E6%89%BF\">寄生继承</a></li>\n</ul>\n</li>\n<li><a href=\"#foo--foobar-%EF%BC%8C%E8%BF%99%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E5%86%99%EF%BC%9F\">foo = foo||bar ，这行代码是什么意思？为什么要这样写？</a></li>\n<li><a href=\"#caller-%E5%92%8C-callee-%E7%9A%84%E5%8C%BA%E5%88%AB\">caller 和 callee 的区别</a></li>\n<li><a href=\"#%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E4%BA%8B%E5%8A%A1%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B\">一次完整的HTTP事务是怎样的一个过程</a></li>\n<li><a href=\"#%E5%9C%A8cssjs%E4%BB%A3%E7%A0%81%E4%B8%8A%E7%BA%BF%E4%B9%8B%E5%90%8E%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%EF%BC%8C%E4%BB%8E%E7%94%A8%E6%88%B7%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%B8%80%E6%AC%A1js%E8%AF%B7%E6%B1%82%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BC%9A%E6%9C%89%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%EF%BC%9F\">在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？</a></li>\n<li><a href=\"#%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%88%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%EF%BC%89%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BB%99%E7%94%A8%E6%88%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C%E3%80%82\">一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</a></li>\n<li><a href=\"#%E8%AF%B7%E7%94%A8css%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%BB%E7%81%AF%E7%89%87%E6%95%88%E6%9E%9C%E9%A1%B5%E9%9D%A2\">请用Css写一个简单的幻灯片效果页面</a></li>\n<li><a href=\"#%E5%A4%96%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%E5%B0%B1%E6%98%AFmargin-collapse\">外边距重叠就是margin-collapse</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%EF%BC%9F\">如何垂直居中一个浮动元素？</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AAimg\">如何垂直居中一个<img></a></li>\n<li><a href=\"#vue-%E9%9D%A2%E8%AF%95%E9%A2%98\">VUE 面试题</a>\n<ul>\n<li><a href=\"#%E8%AF%B7%E8%B0%88%E8%B0%88vue%E4%B8%AD%E7%9A%84mvvm%E6%A8%A1%E5%BC%8F\">请谈谈Vue中的MVVM模式</a></li>\n<li><a href=\"#v-show%E5%92%8Cv-if%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9\">v-show和v-if指令的共同点和不同点?</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E8%AE%A9css%E5%8F%AA%E5%9C%A8%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%B5%B7%E4%BD%9C%E7%94%A8\">如何让CSS只在当前组件中起作用?</a></li>\n<li><a href=\"#keep-alive%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88\">keep-alive的作用是什么?</a></li>\n<li><a href=\"#vue%E4%B8%AD%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4\">Vue中引入组件的步骤?</a></li>\n<li><a href=\"#%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4\">在Vue中使用插件的步骤</a></li>\n<li><a href=\"#%E8%AF%B7%E5%88%97%E4%B8%BE%E5%87%BA3%E4%B8%AAvue%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0\">请列举出3个Vue中常用的生命周期钩子函数?</a></li>\n<li><a href=\"#%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%8Bvuex%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\">请简述下Vuex的原理和使用方法</a></li>\n</ul>\n</li>\n</ul>\n";
</script>
<script src="assets/js/app.js"></script>

</body>
</html>

